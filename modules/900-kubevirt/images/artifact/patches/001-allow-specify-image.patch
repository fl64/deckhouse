diff --git a/Makefile b/Makefile
index 729d9b4e954..7e8c8d3523b 100644
--- a/Makefile
+++ b/Makefile
@@ -194,6 +194,7 @@ lint:
 	hack/dockerized "golangci-lint run --timeout 20m --verbose \
 	  pkg/network/namescheme/... \
 	  pkg/network/domainspec/... \
+	  pkg/network/sriov/... \
 	  tests/console/... \
 	  tests/libnet/... \
 	  tests/libvmi/... \
diff --git a/manifests/generated/operator-csv.yaml.in b/manifests/generated/operator-csv.yaml.in
index 9390d5c7fa2..509ab9b956f 100644
--- a/manifests/generated/operator-csv.yaml.in
+++ b/manifests/generated/operator-csv.yaml.in
@@ -503,6 +503,7 @@ spec:
           - delete
           - update
           - create
+          - patch
         - apiGroups:
           - ""
           resources:
diff --git a/manifests/generated/rbac-operator.authorization.k8s.yaml.in b/manifests/generated/rbac-operator.authorization.k8s.yaml.in
index e05a77816e2..35c7d4f1517 100644
--- a/manifests/generated/rbac-operator.authorization.k8s.yaml.in
+++ b/manifests/generated/rbac-operator.authorization.k8s.yaml.in
@@ -422,6 +422,7 @@ rules:
   - delete
   - update
   - create
+  - patch
 - apiGroups:
   - ""
   resources:
diff --git a/pkg/network/sriov/BUILD.bazel b/pkg/network/sriov/BUILD.bazel
index fd09d0e0773..64775ea2ea7 100644
--- a/pkg/network/sriov/BUILD.bazel
+++ b/pkg/network/sriov/BUILD.bazel
@@ -1,8 +1,30 @@
-load("@io_bazel_rules_go//go:def.bzl", "go_library")
+load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
     srcs = ["sriov.go"],
     importpath = "kubevirt.io/kubevirt/pkg/network/sriov",
     visibility = ["//visibility:public"],
+    deps = [
+        "//pkg/network/namescheme:go_default_library",
+        "//pkg/network/vmispec:go_default_library",
+        "//staging/src/kubevirt.io/api/core/v1:go_default_library",
+        "//staging/src/kubevirt.io/client-go/log:go_default_library",
+        "//vendor/github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = [
+        "sriov_suite_test.go",
+        "sriov_test.go",
+    ],
+    deps = [
+        ":go_default_library",
+        "//staging/src/kubevirt.io/api/core/v1:go_default_library",
+        "//staging/src/kubevirt.io/client-go/testutils:go_default_library",
+        "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
+        "//vendor/github.com/onsi/gomega:go_default_library",
+    ],
 )
diff --git a/pkg/network/sriov/sriov.go b/pkg/network/sriov/sriov.go
index 3181f570b41..ead4d5b43a2 100644
--- a/pkg/network/sriov/sriov.go
+++ b/pkg/network/sriov/sriov.go
@@ -19,4 +19,83 @@
 
 package sriov
 
-const AliasPrefix = "sriov-"
+import (
+	"encoding/json"
+	"fmt"
+
+	networkv1 "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1"
+	v1 "kubevirt.io/api/core/v1"
+	"kubevirt.io/client-go/log"
+
+	"kubevirt.io/kubevirt/pkg/network/namescheme"
+	"kubevirt.io/kubevirt/pkg/network/vmispec"
+)
+
+const (
+	AliasPrefix        = "sriov-"
+	NetworkPCIMapAnnot = "kubevirt.io/network-pci-map"
+	MountPath          = "/etc/podinfo"
+	VolumeName         = "network-pci-map-annotation"
+	VolumePath         = "network-pci-map"
+)
+
+func CreateNetworkPCIAnnotationValue(networks []v1.Network, interfaces []v1.Interface, networkStatusAnnotationValue string) string {
+	networkPCIMap, err := mapNetworkNameToPCIAddress(networks, interfaces, networkStatusAnnotationValue)
+	if err != nil {
+		log.Log.Warningf("failed to create network-pci-map: %v", err)
+		networkPCIMap = map[string]string{}
+	}
+
+	networkPCIMapBytes, err := json.Marshal(networkPCIMap)
+	if err != nil {
+		log.Log.Warningf("failed to marshal network-pci-map: %v", err)
+		return ""
+	}
+
+	return string(networkPCIMapBytes)
+}
+
+func mapNetworkNameToPCIAddress(networks []v1.Network, interfaces []v1.Interface,
+	networkStatusAnnotationValue string) (map[string]string, error) {
+	multusInterfaceNameToNetworkStatusMap, err := mapMultusInterfaceNameToNetworkStatus(networkStatusAnnotationValue)
+	if err != nil {
+		return nil, err
+	}
+	networkNameScheme := namescheme.CreateNetworkNameScheme(networks)
+
+	networkPCIMap := map[string]string{}
+	for _, sriovIface := range vmispec.FilterSRIOVInterfaces(interfaces) {
+		multusInterfaceName := networkNameScheme[sriovIface.Name]
+		networkStatusEntry, exist := multusInterfaceNameToNetworkStatusMap[multusInterfaceName]
+		if !exist {
+			return nil, fmt.Errorf("failed to find network-status entry with interface %q", multusInterfaceName)
+		}
+		if networkStatusEntry.DeviceInfo == nil || networkStatusEntry.DeviceInfo.Pci == nil {
+			return nil, fmt.Errorf("failed to find device-info/pci-address in network-status annotation for SR-IOV interface %q", sriovIface.Name)
+		}
+
+		pciAddress := networkStatusEntry.DeviceInfo.Pci.PciAddress
+		if pciAddress == "" {
+			return nil, fmt.Errorf("failed to associate pci-address to SR-IOV interface %q", sriovIface.Name)
+		}
+		networkPCIMap[sriovIface.Name] = pciAddress
+	}
+	return networkPCIMap, nil
+}
+
+func mapMultusInterfaceNameToNetworkStatus(networkStatusAnnotationValue string) (map[string]networkv1.NetworkStatus, error) {
+	if networkStatusAnnotationValue == "" {
+		return nil, fmt.Errorf("network-status annotation is not present")
+	}
+	var networkStatusList []networkv1.NetworkStatus
+	if err := json.Unmarshal([]byte(networkStatusAnnotationValue), &networkStatusList); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal network-status annotation: %v", err)
+	}
+
+	multusInterfaceNameToNetworkStatusMap := map[string]networkv1.NetworkStatus{}
+	for _, networkStatus := range networkStatusList {
+		multusInterfaceNameToNetworkStatusMap[networkStatus.Interface] = networkStatus
+	}
+
+	return multusInterfaceNameToNetworkStatusMap, nil
+}
diff --git a/pkg/network/sriov/sriov_suite_test.go b/pkg/network/sriov/sriov_suite_test.go
new file mode 100644
index 00000000000..56af4468cff
--- /dev/null
+++ b/pkg/network/sriov/sriov_suite_test.go
@@ -0,0 +1,30 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright 2022 Red Hat, Inc.
+ *
+ */
+
+package sriov_test
+
+import (
+	"testing"
+
+	"kubevirt.io/client-go/testutils"
+)
+
+func TestSRIOV(t *testing.T) {
+	testutils.KubeVirtTestSuiteSetup(t)
+}
diff --git a/pkg/network/sriov/sriov_test.go b/pkg/network/sriov/sriov_test.go
new file mode 100644
index 00000000000..885950c68e5
--- /dev/null
+++ b/pkg/network/sriov/sriov_test.go
@@ -0,0 +1,312 @@
+/*
+* This file is part of the KubeVirt project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+* Copyright 2022 Red Hat, Inc.
+*
+ */
+
+package sriov_test
+
+import (
+	"kubevirt.io/kubevirt/pkg/network/sriov"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	virtv1 "kubevirt.io/api/core/v1"
+)
+
+var _ = Describe("SRIOV", func() {
+	networkStatusWithOneSRIOVNetwork := `
+[
+{
+  "name": "kindnet",
+  "interface": "eth0",
+  "ips": [
+    "10.244.2.131"
+  ],
+  "mac": "82:cf:7c:98:43:7e",
+  "default": true,
+  "dns": {}
+},
+{
+  "name": "default/nad1",
+  "interface": "net1",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:04:02.5"
+    }
+  }
+}
+]`
+	networkStatusWithTwoSRIOVNetworks := `
+[
+{
+  "name": "kindnet",
+  "interface": "eth0",
+  "ips": [
+    "10.244.2.131"
+  ],
+  "mac": "82:cf:7c:98:43:7e",
+  "default": true,
+  "dns": {}
+},
+{
+  "name": "default/nad1",
+  "interface": "net1",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:04:02.5"
+    }
+  }
+},
+{
+  "name": "default/nad2",
+  "interface": "net2",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:04:02.2"
+    }
+  }
+}
+]`
+	networkStatusWithOneBridgeOneSRIOVNetworks := `
+[
+{
+  "name": "kindnet",
+  "interface": "eth0",
+  "ips": [
+    "10.244.1.9"
+  ],
+  "mac": "3a:7e:42:fa:37:c6",
+  "default": true,
+  "dns": {}
+},
+{
+  "name": "default/bridge-network",
+  "interface": "net1",
+  "mac": "8a:37:d9:e7:0f:18",
+  "dns": {}
+},
+{
+  "name": "default/sriov-network-vlan100",
+  "interface": "net2",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:65:00.2"
+    }
+  }
+}
+]`
+	networkStatusWithTwoSRIOVNetworksButOneWithNoPCIData := `
+[
+{
+  "name": "kindnet",
+  "interface": "eth0",
+  "ips": [
+    "10.244.2.131"
+  ],
+  "mac": "82:cf:7c:98:43:7e",
+  "default": true,
+  "dns": {}
+},
+{
+  "name": "default/nad1",
+  "interface": "net1",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:04:02.5"
+    }
+  }
+},
+{
+  "name": "default/nad1",
+  "interface": "net2",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0"
+  }
+}
+]`
+	networkStatusWithTwoSRIOVNetworksButOneWithNoDeviceInfoData := `
+[
+{
+  "name": "kindnet",
+  "interface": "eth0",
+  "ips": [
+    "10.244.2.131"
+  ],
+  "mac": "82:cf:7c:98:43:7e",
+  "default": true,
+  "dns": {}
+},
+{
+  "name": "default/nad1",
+  "interface": "net1",
+  "dns": {},
+  "device-info": {
+    "type": "pci",
+    "version": "1.0.0",
+    "pci": {
+      "pci-address": "0000:04:02.5"
+    }
+  }
+},
+{
+  "name": "default/nad1",
+  "interface": "net2",
+  "dns": {}
+}
+]`
+	DescribeTable("should fail to prepare network pci map on the pod network-pci-map anotation",
+		func(networkList []virtv1.Network, interfaceList []virtv1.Interface, networkStatusAnnotationValue string) {
+			networkPCIAnnotationValue := sriov.CreateNetworkPCIAnnotationValue(networkList, interfaceList, networkStatusAnnotationValue)
+			Expect(networkPCIAnnotationValue).To(Equal("{}"))
+		},
+		Entry("when pod's networkStatus Annotation does not exist",
+			[]virtv1.Network{newMultusNetwork("foo", "default/nad1")},
+			[]virtv1.Interface{newSRIOVInterface("foo")},
+			"",
+		),
+		Entry("when networkStatusAnnotation is valid but one SR-IOV entry is missing",
+			[]virtv1.Network{
+				newMultusNetwork("foo", "default/nad1"),
+				newMultusNetwork("boo", "default/nad2"),
+			},
+			[]virtv1.Interface{
+				newSRIOVInterface("foo"),
+				newSRIOVInterface("boo"),
+			},
+			networkStatusWithOneSRIOVNetwork,
+		),
+		Entry("when networkStatusAnnotation is valid but with no pci data on one of the SRIOV interfaces",
+			[]virtv1.Network{
+				newMultusNetwork("foo", "default/nad1"),
+				newMultusNetwork("boo", "default/nad2"),
+			},
+			[]virtv1.Interface{
+				newSRIOVInterface("foo"),
+				newSRIOVInterface("boo"),
+			},
+			networkStatusWithTwoSRIOVNetworksButOneWithNoPCIData,
+		),
+		Entry("when networkStatusAnnotation is valid but with no device-info data on one of the SRIOV interfaces",
+			[]virtv1.Network{
+				newMultusNetwork("foo", "default/nad1"),
+				newMultusNetwork("boo", "default/nad2"),
+			},
+			[]virtv1.Interface{
+				newSRIOVInterface("foo"),
+				newSRIOVInterface("boo"),
+			},
+			networkStatusWithTwoSRIOVNetworksButOneWithNoDeviceInfoData,
+		),
+	)
+
+	DescribeTable("should succeed to prepare network pci map on pod's network-pci-map",
+		func(networkList []virtv1.Network, interfaceList []virtv1.Interface, networkStatusAnnotationValue, expectedPciMapString string) {
+			Expect(sriov.CreateNetworkPCIAnnotationValue(networkList, interfaceList, networkStatusAnnotationValue)).To(Equal(expectedPciMapString))
+		},
+		Entry("when given Interfaces{1X masquarade(primary),1X SRIOV}; Networks{1X masquarade(primary),1X Multus} 1xNAD",
+			[]virtv1.Network{newMasqueradeDefaultNetwork("testmasquerade"), newMultusNetwork("foo", "default/nad1")},
+			[]virtv1.Interface{newMasqueradePrimaryInterface("testmasquerade"), newSRIOVInterface("foo")},
+			networkStatusWithOneSRIOVNetwork,
+			`{"foo":"0000:04:02.5"}`,
+		),
+		Entry("when given Interfaces{1X masquarade(primary),2X SRIOV}, Networks{1X masquarade(primary),2X Multus}, 2xNAD",
+			[]virtv1.Network{
+				newMasqueradeDefaultNetwork("testmasquerade"),
+				newMultusNetwork("foo", "default/nad1"),
+				newMultusNetwork("boo", "default/nad2"),
+			},
+			[]virtv1.Interface{
+				newMasqueradePrimaryInterface("testmasquerade"),
+				newSRIOVInterface("boo"), newSRIOVInterface("foo"),
+			},
+			networkStatusWithTwoSRIOVNetworks,
+			`{"boo":"0000:04:02.2","foo":"0000:04:02.5"}`,
+		),
+		Entry("when given Interfaces{1X masquarade(primary),1X SRIOV, 1X Bridge}  Networks{1X masquarade(primary),2X Multus}, 2xNAD",
+			[]virtv1.Network{
+				newMasqueradeDefaultNetwork("testmasquerade"),
+				newMultusNetwork("boo", "default/nad1"),
+				newMultusNetwork("foo", "default/nad2"),
+			},
+			[]virtv1.Interface{
+				newMasqueradePrimaryInterface("testmasquerade"),
+				newBridgeInterface("boo"), newSRIOVInterface("foo"),
+			},
+			networkStatusWithOneBridgeOneSRIOVNetworks,
+			`{"foo":"0000:65:00.2"}`,
+		),
+	)
+})
+
+func newSRIOVInterface(name string) virtv1.Interface {
+	return virtv1.Interface{
+		Name:                   name,
+		InterfaceBindingMethod: virtv1.InterfaceBindingMethod{SRIOV: &virtv1.InterfaceSRIOV{}},
+	}
+}
+
+func newBridgeInterface(name string) virtv1.Interface {
+	return virtv1.Interface{
+		Name:                   name,
+		InterfaceBindingMethod: virtv1.InterfaceBindingMethod{Bridge: &virtv1.InterfaceBridge{}},
+	}
+}
+
+func newMasqueradePrimaryInterface(name string) virtv1.Interface {
+	return virtv1.Interface{
+		Name:                   name,
+		InterfaceBindingMethod: virtv1.InterfaceBindingMethod{Masquerade: &virtv1.InterfaceMasquerade{}},
+	}
+}
+
+func newMasqueradeDefaultNetwork(name string) virtv1.Network {
+	return virtv1.Network{
+		Name: name,
+		NetworkSource: virtv1.NetworkSource{
+			Pod: &virtv1.PodNetwork{},
+		},
+	}
+}
+
+func newMultusNetwork(name, networkName string) virtv1.Network {
+	return virtv1.Network{
+		Name: name,
+		NetworkSource: virtv1.NetworkSource{
+			Multus: &virtv1.MultusNetwork{
+				NetworkName: networkName,
+			},
+		},
+	}
+}
diff --git a/pkg/network/vmispec/interface.go b/pkg/network/vmispec/interface.go
index fe0a2c37834..8d067b138b6 100644
--- a/pkg/network/vmispec/interface.go
+++ b/pkg/network/vmispec/interface.go
@@ -39,6 +39,15 @@ func FilterSRIOVInterfaces(ifaces []v1.Interface) []v1.Interface {
 	return sriovIfaces
 }
 
+func SRIOVInterfaceExist(ifaces []v1.Interface) bool {
+	for _, iface := range ifaces {
+		if iface.SRIOV != nil {
+			return true
+		}
+	}
+	return false
+}
+
 func FilterInterfacesSpec(ifaces []v1.Interface, predicate func(i v1.Interface) bool) []v1.Interface {
 	var filteredIfaces []v1.Interface
 	for _, iface := range ifaces {
diff --git a/pkg/network/vmispec/interface_test.go b/pkg/network/vmispec/interface_test.go
index 3dd09e35c7e..afa5e9bcfab 100644
--- a/pkg/network/vmispec/interface_test.go
+++ b/pkg/network/vmispec/interface_test.go
@@ -65,6 +65,7 @@ var _ = Describe("VMI network spec", func() {
 			}
 
 			Expect(netvmispec.FilterSRIOVInterfaces(ifaces)).To(BeEmpty())
+			Expect(netvmispec.SRIOVInterfaceExist(ifaces)).To(BeFalse())
 		})
 
 		It("finds two SR-IOV interfaces in list", func() {
@@ -87,6 +88,7 @@ var _ = Describe("VMI network spec", func() {
 			}
 
 			Expect(netvmispec.FilterSRIOVInterfaces(ifaces)).To(Equal([]v1.Interface{sriov_net1, sriov_net2}))
+			Expect(netvmispec.SRIOVInterfaceExist(ifaces)).To(BeTrue())
 		})
 	})
 
diff --git a/pkg/util/types/patch.go b/pkg/util/types/patch.go
index a8c643945c1..8d349cac6e3 100644
--- a/pkg/util/types/patch.go
+++ b/pkg/util/types/patch.go
@@ -35,6 +35,7 @@ const (
 	PatchReplaceOp = "replace"
 	PatchTestOp    = "test"
 	PatchAddOp     = "add"
+	PatchRemoveOp  = "remove"
 )
 
 func GeneratePatchPayload(patches ...PatchOperation) ([]byte, error) {
diff --git a/pkg/util/util.go b/pkg/util/util.go
index c43521143e2..8e8a51d5aec 100644
--- a/pkg/util/util.go
+++ b/pkg/util/util.go
@@ -86,6 +86,17 @@ func IsSEVVMI(vmi *v1.VirtualMachineInstance) bool {
 	return vmi.Spec.Domain.LaunchSecurity != nil && vmi.Spec.Domain.LaunchSecurity.SEV != nil
 }
 
+func IsVmiUsingHyperVReenlightenment(vmi *v1.VirtualMachineInstance) bool {
+	if vmi == nil {
+		return false
+	}
+
+	domainFeatures := vmi.Spec.Domain.Features
+
+	return domainFeatures != nil && domainFeatures.Hyperv != nil && domainFeatures.Hyperv.Reenlightenment != nil &&
+		domainFeatures.Hyperv.Reenlightenment.Enabled != nil && *domainFeatures.Hyperv.Reenlightenment.Enabled
+}
+
 // WantVirtioNetDevice checks whether a VMI references at least one "virtio" network interface.
 // Note that the reference can be explicit or implicit (unspecified nic models defaults to "virtio").
 func WantVirtioNetDevice(vmi *v1.VirtualMachineInstance) bool {
diff --git a/pkg/virt-controller/services/BUILD.bazel b/pkg/virt-controller/services/BUILD.bazel
index 1eb6f51be50..60531321130 100644
--- a/pkg/virt-controller/services/BUILD.bazel
+++ b/pkg/virt-controller/services/BUILD.bazel
@@ -19,6 +19,7 @@ go_library(
         "//pkg/host-disk:go_default_library",
         "//pkg/network/istio:go_default_library",
         "//pkg/network/namescheme:go_default_library",
+        "//pkg/network/sriov:go_default_library",
         "//pkg/network/vmispec:go_default_library",
         "//pkg/storage/types:go_default_library",
         "//pkg/util:go_default_library",
diff --git a/pkg/virt-controller/services/rendervolumes.go b/pkg/virt-controller/services/rendervolumes.go
index 077442a0065..a1c74feb4a6 100644
--- a/pkg/virt-controller/services/rendervolumes.go
+++ b/pkg/virt-controller/services/rendervolumes.go
@@ -14,6 +14,7 @@ import (
 	"kubevirt.io/kubevirt/pkg/config"
 	"kubevirt.io/kubevirt/pkg/hooks"
 	hostdisk "kubevirt.io/kubevirt/pkg/host-disk"
+	"kubevirt.io/kubevirt/pkg/network/sriov"
 	"kubevirt.io/kubevirt/pkg/storage/types"
 	"kubevirt.io/kubevirt/pkg/util"
 )
@@ -98,6 +99,24 @@ func emptyDirVolume(name string) k8sv1.Volume {
 	}
 }
 
+func downwardAPIDirVolume(name, path, fieldPath string) k8sv1.Volume {
+	return k8sv1.Volume{
+		Name: name,
+		VolumeSource: k8sv1.VolumeSource{
+			DownwardAPI: &k8sv1.DownwardAPIVolumeSource{
+				Items: []k8sv1.DownwardAPIVolumeFile{
+					{
+						Path: path,
+						FieldRef: &k8sv1.ObjectFieldSelector{
+							FieldPath: fieldPath,
+						},
+					},
+				},
+			},
+		},
+	}
+}
+
 func withVMIVolumes(pvcStore cache.Store, vmiSpecVolumes []v1.Volume, vmiVolumeStatus []v1.VolumeStatus) VolumeRendererOption {
 	return func(renderer *VolumeRenderer) error {
 		hotplugVolumesByName := hotplugVolumes(vmiVolumeStatus, vmiSpecVolumes)
@@ -325,6 +344,17 @@ func withHotplugSupport(hotplugDiskDir string) VolumeRendererOption {
 	}
 }
 
+func withSRIOVPciMapAnnotation() VolumeRendererOption {
+	return func(renderer *VolumeRenderer) error {
+		renderer.podVolumeMounts = append(renderer.podVolumeMounts, mountPath(sriov.VolumeName, sriov.MountPath))
+		renderer.podVolumes = append(renderer.podVolumes,
+			downwardAPIDirVolume(
+				sriov.VolumeName, sriov.VolumePath, fmt.Sprintf("metadata.annotations['%s']", sriov.NetworkPCIMapAnnot)),
+		)
+		return nil
+	}
+}
+
 func imgPullSecrets(volumes ...v1.Volume) []k8sv1.LocalObjectReference {
 	var imagePullSecrets []k8sv1.LocalObjectReference
 	for _, volume := range volumes {
diff --git a/pkg/virt-controller/services/template.go b/pkg/virt-controller/services/template.go
index 6711903cf13..5324ac1953e 100644
--- a/pkg/virt-controller/services/template.go
+++ b/pkg/virt-controller/services/template.go
@@ -46,6 +46,7 @@ import (
 	containerdisk "kubevirt.io/kubevirt/pkg/container-disk"
 	"kubevirt.io/kubevirt/pkg/hooks"
 	"kubevirt.io/kubevirt/pkg/network/istio"
+	"kubevirt.io/kubevirt/pkg/network/vmispec"
 	"kubevirt.io/kubevirt/pkg/storage/types"
 	"kubevirt.io/kubevirt/pkg/util"
 	"kubevirt.io/kubevirt/pkg/util/net/dns"
@@ -769,6 +770,10 @@ func (t *templateService) newVolumeRenderer(vmi *v1.VirtualMachineInstance, name
 		volumeOpts = append(volumeOpts, withHotplugSupport(t.hotplugDiskDir))
 	}
 
+	if vmispec.SRIOVInterfaceExist(vmi.Spec.Domain.Devices.Interfaces) {
+		volumeOpts = append(volumeOpts, withSRIOVPciMapAnnotation())
+	}
+
 	volumeRenderer, err := NewVolumeRenderer(
 		namespace,
 		t.ephemeralDiskDir,
diff --git a/pkg/virt-controller/watch/BUILD.bazel b/pkg/virt-controller/watch/BUILD.bazel
index 212399f5041..2ae48ad59e6 100644
--- a/pkg/virt-controller/watch/BUILD.bazel
+++ b/pkg/virt-controller/watch/BUILD.bazel
@@ -1,5 +1,4 @@
 load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
-load("@kubevirt//tools/ginkgo:ginkgo.bzl", "ginkgo_test")
 
 go_library(
     name = "go_default_library",
@@ -26,6 +25,8 @@ go_library(
         "//pkg/monitoring/perfscale:go_default_library",
         "//pkg/monitoring/profiler:go_default_library",
         "//pkg/monitoring/vmistats:go_default_library",
+        "//pkg/network/sriov:go_default_library",
+        "//pkg/network/vmispec:go_default_library",
         "//pkg/service:go_default_library",
         "//pkg/storage/export/export:go_default_library",
         "//pkg/storage/snapshot:go_default_library",
@@ -60,6 +61,7 @@ go_library(
         "//staging/src/kubevirt.io/client-go/log:go_default_library",
         "//staging/src/kubevirt.io/client-go/util:go_default_library",
         "//vendor/github.com/emicklei/go-restful:go_default_library",
+        "//vendor/github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1:go_default_library",
         "//vendor/github.com/kubernetes-csi/external-snapshotter/client/v4/apis/volumesnapshot/v1:go_default_library",
         "//vendor/github.com/pborman/uuid:go_default_library",
         "//vendor/github.com/prometheus/client_golang/prometheus:go_default_library",
@@ -109,11 +111,11 @@ go_test(
         "watch_suite_test.go",
     ],
     embed = [":go_default_library"],
-    tags = ["cov"],
     deps = [
         "//pkg/controller:go_default_library",
         "//pkg/instancetype:go_default_library",
         "//pkg/monitoring/migration:go_default_library",
+        "//pkg/network/sriov:go_default_library",
         "//pkg/rest:go_default_library",
         "//pkg/storage/export/export:go_default_library",
         "//pkg/storage/snapshot:go_default_library",
@@ -146,6 +148,7 @@ go_test(
         "//vendor/github.com/emicklei/go-restful:go_default_library",
         "//vendor/github.com/evanphx/json-patch:go_default_library",
         "//vendor/github.com/golang/mock/gomock:go_default_library",
+        "//vendor/github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1:go_default_library",
         "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
         "//vendor/github.com/onsi/gomega/gstruct:go_default_library",
@@ -177,10 +180,3 @@ go_test(
         "//vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1:go_default_library",
     ],
 )
-
-ginkgo_test(
-    name = "go_parallel_test",
-    ginkgo_args = ["-p"],
-    go_test = ":go_default_test",
-    tags = ["nocov"],
-)
diff --git a/pkg/virt-controller/watch/topology/BUILD.bazel b/pkg/virt-controller/watch/topology/BUILD.bazel
index 847824f1205..ada12c7a4f5 100644
--- a/pkg/virt-controller/watch/topology/BUILD.bazel
+++ b/pkg/virt-controller/watch/topology/BUILD.bazel
@@ -13,6 +13,7 @@ go_library(
     importpath = "kubevirt.io/kubevirt/pkg/virt-controller/watch/topology",
     visibility = ["//visibility:public"],
     deps = [
+        "//pkg/util:go_default_library",
         "//pkg/util/nodes:go_default_library",
         "//pkg/virt-config:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
diff --git a/pkg/virt-controller/watch/topology/generated_mock_hinter.go b/pkg/virt-controller/watch/topology/generated_mock_hinter.go
index 97f9584d35a..2e152c8619d 100644
--- a/pkg/virt-controller/watch/topology/generated_mock_hinter.go
+++ b/pkg/virt-controller/watch/topology/generated_mock_hinter.go
@@ -29,25 +29,26 @@ func (_m *MockHinter) EXPECT() *_MockHinterRecorder {
 	return _m.recorder
 }
 
-func (_m *MockHinter) TopologyHintsForVMI(vmi *v1.VirtualMachineInstance) (*v1.TopologyHints, error) {
+func (_m *MockHinter) TopologyHintsForVMI(vmi *v1.VirtualMachineInstance) (*v1.TopologyHints, TscFrequencyRequirementType, error) {
 	ret := _m.ctrl.Call(_m, "TopologyHintsForVMI", vmi)
 	ret0, _ := ret[0].(*v1.TopologyHints)
-	ret1, _ := ret[1].(error)
-	return ret0, ret1
+	ret1, _ := ret[1].(TscFrequencyRequirementType)
+	ret2, _ := ret[2].(error)
+	return ret0, ret1, ret2
 }
 
 func (_mr *_MockHinterRecorder) TopologyHintsForVMI(arg0 interface{}) *gomock.Call {
 	return _mr.mock.ctrl.RecordCall(_mr.mock, "TopologyHintsForVMI", arg0)
 }
 
-func (_m *MockHinter) TopologyHintsRequiredForVMI(vmi *v1.VirtualMachineInstance) bool {
-	ret := _m.ctrl.Call(_m, "TopologyHintsRequiredForVMI", vmi)
+func (_m *MockHinter) IsTscFrequencyRequiredForBoot(vmi *v1.VirtualMachineInstance) bool {
+	ret := _m.ctrl.Call(_m, "IsTscFrequencyRequiredForBoot", vmi)
 	ret0, _ := ret[0].(bool)
 	return ret0
 }
 
-func (_mr *_MockHinterRecorder) TopologyHintsRequiredForVMI(arg0 interface{}) *gomock.Call {
-	return _mr.mock.ctrl.RecordCall(_mr.mock, "TopologyHintsRequiredForVMI", arg0)
+func (_mr *_MockHinterRecorder) IsTscFrequencyRequiredForBoot(arg0 interface{}) *gomock.Call {
+	return _mr.mock.ctrl.RecordCall(_mr.mock, "IsTscFrequencyRequiredForBoot", arg0)
 }
 
 func (_m *MockHinter) TSCFrequenciesInUse() []int64 {
diff --git a/pkg/virt-controller/watch/topology/hinter.go b/pkg/virt-controller/watch/topology/hinter.go
index c8cd0399346..b686d3c8c17 100644
--- a/pkg/virt-controller/watch/topology/hinter.go
+++ b/pkg/virt-controller/watch/topology/hinter.go
@@ -14,8 +14,8 @@ import (
 )
 
 type Hinter interface {
-	TopologyHintsForVMI(vmi *k6tv1.VirtualMachineInstance) (hints *k6tv1.TopologyHints, err error)
-	TopologyHintsRequiredForVMI(vmi *k6tv1.VirtualMachineInstance) bool
+	TopologyHintsForVMI(vmi *k6tv1.VirtualMachineInstance) (hints *k6tv1.TopologyHints, requirement TscFrequencyRequirementType, err error)
+	IsTscFrequencyRequiredForBoot(vmi *k6tv1.VirtualMachineInstance) bool
 	TSCFrequenciesInUse() []int64
 	LowestTSCFrequencyOnCluster() (int64, error)
 }
@@ -27,21 +27,23 @@ type topologyHinter struct {
 	arch          string
 }
 
-func (t *topologyHinter) TopologyHintsRequiredForVMI(vmi *k6tv1.VirtualMachineInstance) bool {
-	return t.arch == "amd64" && IsManualTSCFrequencyRequired(vmi)
+func (t *topologyHinter) IsTscFrequencyRequiredForBoot(vmi *k6tv1.VirtualMachineInstance) bool {
+	return t.arch == "amd64" && GetTscFrequencyRequirement(vmi).Type == RequiredForBoot
 }
 
-func (t *topologyHinter) TopologyHintsForVMI(vmi *k6tv1.VirtualMachineInstance) (hints *k6tv1.TopologyHints, err error) {
-	if t.TopologyHintsRequiredForVMI(vmi) {
-		freq, err := t.LowestTSCFrequencyOnCluster()
-		if err != nil {
-			return nil, fmt.Errorf("failed to determine the lowest tsc frequency on the cluster: %v", err)
-		}
-		return &k6tv1.TopologyHints{
-			TSCFrequency: pointer.Int64Ptr(freq),
-		}, nil
+func (t *topologyHinter) TopologyHintsForVMI(vmi *k6tv1.VirtualMachineInstance) (hints *k6tv1.TopologyHints, requirement TscFrequencyRequirementType, err error) {
+	requirement = GetTscFrequencyRequirement(vmi).Type
+	if requirement == NotRequired || t.arch != "amd64" {
+		return
+	}
+
+	freq, err := t.LowestTSCFrequencyOnCluster()
+	if err != nil {
+		return nil, requirement, fmt.Errorf("failed to determine the lowest tsc frequency on the cluster: %v", err)
 	}
-	return nil, nil
+
+	hints = &k6tv1.TopologyHints{TSCFrequency: pointer.Int64Ptr(freq)}
+	return
 }
 
 func (t *topologyHinter) LowestTSCFrequencyOnCluster() (int64, error) {
diff --git a/pkg/virt-controller/watch/topology/hinter_test.go b/pkg/virt-controller/watch/topology/hinter_test.go
index 036959d4b89..fb5e96aebd9 100644
--- a/pkg/virt-controller/watch/topology/hinter_test.go
+++ b/pkg/virt-controller/watch/topology/hinter_test.go
@@ -52,9 +52,7 @@ var _ = Describe("Hinter", func() {
 			NodeWithTSC("node4", 12, false),
 		)
 		vmi := vmiWithTSCFrequencyOnNode("myvmi", 12, "oldnode")
-		g.Expect(hinter.TopologyHintsRequiredForVMI(
-			vmi),
-		).To(g.BeTrue())
+		g.Expect(GetTscFrequencyRequirement(vmi).Type).ToNot(g.Equal(NotRequired))
 		g.Expect(hinter.TopologyHintsForVMI(vmi)).To(g.Equal(
 			&virtv1.TopologyHints{
 				TSCFrequency: pointer.Int64Ptr(12),
@@ -80,10 +78,11 @@ var _ = Describe("Hinter", func() {
 		)
 		hinter.arch = arch
 		vmi := vmiWithoutTSCFrequency("myvmi")
-		g.Expect(hinter.TopologyHintsRequiredForVMI(
-			vmi),
-		).To(g.BeFalse())
-		g.Expect(hinter.TopologyHintsForVMI(vmi)).To(g.BeNil())
+		g.Expect(hinter.IsTscFrequencyRequiredForBoot(vmi)).To(g.BeFalse())
+
+		hints, _, err := hinter.TopologyHintsForVMI(vmi)
+		g.Expect(hints).To(g.BeNil())
+		g.Expect(err).To(g.Not(g.HaveOccurred()))
 	},
 		Entry("arm64", "arm64"),
 		Entry("ppc64le", "ppc64le"),
diff --git a/pkg/virt-controller/watch/topology/tsc.go b/pkg/virt-controller/watch/topology/tsc.go
index f324aa85307..376796eb1ae 100644
--- a/pkg/virt-controller/watch/topology/tsc.go
+++ b/pkg/virt-controller/watch/topology/tsc.go
@@ -5,12 +5,27 @@ import (
 	"strconv"
 	"strings"
 
+	"kubevirt.io/kubevirt/pkg/util"
+
 	v1 "k8s.io/api/core/v1"
 
 	k6tv1 "kubevirt.io/api/core/v1"
 	"kubevirt.io/client-go/log"
 )
 
+type TscFrequencyRequirementType int
+
+const (
+	RequiredForBoot TscFrequencyRequirementType = iota
+	RequiredForMigration
+	NotRequired
+)
+
+type TscFrequencyRequirement struct {
+	Type   TscFrequencyRequirementType
+	Reason string
+}
+
 func LowestTSCFrequency(nodes []*v1.Node) int64 {
 	var lowest int64
 	for i, node := range nodes {
@@ -112,7 +127,22 @@ func AreTSCFrequencyTopologyHintsDefined(vmi *k6tv1.VirtualMachineInstance) bool
 }
 
 func IsManualTSCFrequencyRequired(vmi *k6tv1.VirtualMachineInstance) bool {
-	return isVmiUsingHyperVReenlightenment(vmi) || vmiHasInvTSCFeature(vmi)
+	return GetTscFrequencyRequirement(vmi).Type != NotRequired
+}
+
+func GetTscFrequencyRequirement(vmi *k6tv1.VirtualMachineInstance) TscFrequencyRequirement {
+	newRequirement := func(reqType TscFrequencyRequirementType, reason string) TscFrequencyRequirement {
+		return TscFrequencyRequirement{Type: reqType, Reason: reason}
+	}
+
+	if vmiHasInvTSCFeature(vmi) {
+		return newRequirement(RequiredForBoot, "VMI with invtsc CPU feature must have tsc frequency defined in order to boot")
+	}
+	if util.IsVmiUsingHyperVReenlightenment(vmi) {
+		return newRequirement(RequiredForMigration, "HyperV Reenlightenment VMIs cannot migrate when TSC Frequency is not exposed on the cluster: guest timers might be inconsistent")
+	}
+
+	return newRequirement(NotRequired, "")
 }
 
 func vmiHasInvTSCFeature(vmi *k6tv1.VirtualMachineInstance) bool {
@@ -129,14 +159,3 @@ func vmiHasInvTSCFeature(vmi *k6tv1.VirtualMachineInstance) bool {
 	}
 	return false
 }
-
-func isVmiUsingHyperVReenlightenment(vmi *k6tv1.VirtualMachineInstance) bool {
-	if vmi == nil {
-		return false
-	}
-
-	domainFeatures := vmi.Spec.Domain.Features
-
-	return domainFeatures != nil && domainFeatures.Hyperv != nil && domainFeatures.Hyperv.Reenlightenment != nil &&
-		domainFeatures.Hyperv.Reenlightenment.Enabled != nil && *domainFeatures.Hyperv.Reenlightenment.Enabled
-}
diff --git a/pkg/virt-controller/watch/vmi.go b/pkg/virt-controller/watch/vmi.go
index b52b9d75959..57dbe47a79a 100644
--- a/pkg/virt-controller/watch/vmi.go
+++ b/pkg/virt-controller/watch/vmi.go
@@ -27,6 +27,7 @@ import (
 	"strings"
 	"time"
 
+	networkv1 "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1"
 	k8sv1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/api/equality"
 	k8serrors "k8s.io/apimachinery/pkg/api/errors"
@@ -38,18 +39,20 @@ import (
 	"k8s.io/client-go/util/workqueue"
 	"k8s.io/utils/trace"
 
-	traceUtils "kubevirt.io/kubevirt/pkg/util/trace"
-	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
-
 	virtv1 "kubevirt.io/api/core/v1"
 	"kubevirt.io/client-go/kubecli"
 	"kubevirt.io/client-go/log"
 	cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
 
 	"kubevirt.io/kubevirt/pkg/controller"
+	"kubevirt.io/kubevirt/pkg/network/sriov"
+	"kubevirt.io/kubevirt/pkg/network/vmispec"
 	kubevirttypes "kubevirt.io/kubevirt/pkg/storage/types"
+	traceUtils "kubevirt.io/kubevirt/pkg/util/trace"
+	patchtypes "kubevirt.io/kubevirt/pkg/util/types"
 	virtconfig "kubevirt.io/kubevirt/pkg/virt-config"
 	"kubevirt.io/kubevirt/pkg/virt-controller/services"
+	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
 )
 
 const (
@@ -131,6 +134,8 @@ const (
 	// NoSuitableNodesForHostModelMigration is set when a VMI with host-model CPU mode tries to migrate but no node
 	// is suitable for migration (since CPU model / required features are not supported)
 	NoSuitableNodesForHostModelMigration = "NoSuitableNodesForHostModelMigration"
+	// FailedPodPatchReason is set when a pod patch error occurs during sync
+	FailedPodPatchReason = "FailedPodPatch"
 )
 
 const failedToRenderLaunchManifestErrFormat = "failed to render launch manifest: %v"
@@ -345,7 +350,30 @@ func (c *VMIController) execute(key string) error {
 	}
 
 	return nil
+}
 
+func (c *VMIController) syncPodAnnotations(pod *k8sv1.Pod, newAnnotations map[string]string) (*k8sv1.Pod, error) {
+	var patchOps []string
+	for key, newValue := range newAnnotations {
+		if podAnnotationValue, keyExist := pod.Annotations[key]; !keyExist || (keyExist && podAnnotationValue != newValue) {
+			patchOp, err := prepareAnnotationsPatchAddOp(key, newValue)
+			if err != nil {
+				return nil, err
+			}
+			patchOps = append(patchOps, patchOp)
+		}
+	}
+	var patchedPod *k8sv1.Pod
+	patchBytes := controller.GeneratePatchBytes(patchOps)
+	if len(patchBytes) > 0 {
+		var err error
+		patchedPod, err = c.clientset.CoreV1().Pods(pod.Namespace).Patch(context.Background(), pod.Name, types.JSONPatchType, patchBytes, v1.PatchOptions{})
+		if err != nil {
+			log.Log.Object(pod).Errorf("failed to sync pod annotations during sync: %v", err)
+			return nil, err
+		}
+	}
+	return patchedPod, nil
 }
 
 func (c *VMIController) setLauncherContainerInfo(vmi *virtv1.VirtualMachineInstance, curPodImage string) *virtv1.VirtualMachineInstance {
@@ -435,7 +463,7 @@ func (c *VMIController) updateStatus(vmi *virtv1.VirtualMachineInstance, pod *k8
 		} else {
 			vmiCopy.Status.Phase = virtv1.Pending
 			if vmi.Status.TopologyHints == nil {
-				if topologyHints, err := c.topologyHinter.TopologyHintsForVMI(vmi); err != nil {
+				if topologyHints, tscRequirement, err := c.topologyHinter.TopologyHintsForVMI(vmi); err != nil && tscRequirement == topology.RequiredForBoot {
 					c.recorder.Eventf(vmi, k8sv1.EventTypeWarning, FailedGatherhingClusterTopologyHints, err.Error())
 					return &syncErrorImpl{err, FailedGatherhingClusterTopologyHints}
 				} else if topologyHints != nil {
@@ -642,6 +670,17 @@ func (c *VMIController) updateStatus(vmi *virtv1.VirtualMachineInstance, pod *k8
 	return nil
 }
 
+func prepareAnnotationsPatchAddOp(key, value string) (string, error) {
+	valueBytes, err := json.Marshal(value)
+	if err != nil {
+		return "", fmt.Errorf("failed to prepare new annotation patchOp for key %s: %v", key, err)
+	}
+
+	key = patchtypes.EscapeJSONPointer(key)
+	return fmt.Sprintf(`{ "op": "add", "path": "/metadata/annotations/%s", "value": %s }`, key, string(valueBytes)), nil
+
+}
+
 func preparePodPatch(oldPod, newPod *k8sv1.Pod) ([]byte, error) {
 	var patchOps []string
 
@@ -1015,7 +1054,7 @@ func (c *VMIController) sync(vmi *virtv1.VirtualMachineInstance, pod *k8sv1.Pod,
 			return nil
 		}
 		// let's check if we already have topology hints or if we are still waiting for them
-		if vmi.Status.TopologyHints == nil && c.topologyHinter.TopologyHintsRequiredForVMI(vmi) {
+		if vmi.Status.TopologyHints == nil && c.topologyHinter.IsTscFrequencyRequiredForBoot(vmi) {
 			log.Log.V(3).Object(vmi).Infof("Delaying pod creation until topology hints are set")
 			return nil
 		}
@@ -1060,6 +1099,18 @@ func (c *VMIController) sync(vmi *virtv1.VirtualMachineInstance, pod *k8sv1.Pod,
 	}
 
 	if !isTempPod(pod) && isPodReady(pod) {
+		if vmispec.SRIOVInterfaceExist(vmi.Spec.Domain.Devices.Interfaces) {
+			networkPCIMapAnnotationValue := sriov.CreateNetworkPCIAnnotationValue(
+				vmi.Spec.Networks, vmi.Spec.Domain.Devices.Interfaces, pod.Annotations[networkv1.NetworkStatusAnnot],
+			)
+			newAnnotations := map[string]string{sriov.NetworkPCIMapAnnot: networkPCIMapAnnotationValue}
+			patchedPod, err := c.syncPodAnnotations(pod, newAnnotations)
+			if err != nil {
+				return &syncErrorImpl{err, FailedPodPatchReason}
+			}
+			*pod = *patchedPod
+		}
+
 		hotplugVolumes := getHotplugVolumes(vmi, pod)
 		hotplugAttachmentPods, err := controller.AttachmentPods(pod, c.podInformer)
 		if err != nil {
diff --git a/pkg/virt-controller/watch/vmi_test.go b/pkg/virt-controller/watch/vmi_test.go
index 6b456a0aa90..737c7ebb249 100644
--- a/pkg/virt-controller/watch/vmi_test.go
+++ b/pkg/virt-controller/watch/vmi_test.go
@@ -29,6 +29,7 @@ import (
 
 	jsonpatch "github.com/evanphx/json-patch"
 	"github.com/golang/mock/gomock"
+	networkv1 "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1"
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
 	. "github.com/onsi/gomega/gstruct"
@@ -54,6 +55,7 @@ import (
 	cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
 
 	kvcontroller "kubevirt.io/kubevirt/pkg/controller"
+	"kubevirt.io/kubevirt/pkg/network/sriov"
 	"kubevirt.io/kubevirt/pkg/testutils"
 	"kubevirt.io/kubevirt/pkg/virt-controller/services"
 	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
@@ -129,6 +131,34 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 		})
 	}
 
+	prependInjectPodPatch := func(pod *k8sv1.Pod) {
+		kubeClient.Fake.PrependReactor("patch", "pods", func(action testing.Action) (handled bool, obj k8sruntime.Object, err error) {
+			originalPodBytes, err := json.Marshal(pod)
+			if err != nil {
+				return false, nil, err
+			}
+
+			patch := action.(testing.PatchAction)
+			patchBytes := patch.GetPatch()
+
+			patchJSON, err := jsonpatch.DecodePatch(patchBytes)
+			if err != nil {
+				return false, nil, err
+			}
+			newPodBytes, err := patchJSON.Apply(originalPodBytes)
+			if err != nil {
+				return false, nil, err
+			}
+
+			var newPod *k8sv1.Pod
+			if err = json.Unmarshal(newPodBytes, &newPod); err != nil {
+				return false, nil, err
+			}
+
+			return true, newPod, nil
+		})
+	}
+
 	shouldExpectVirtualMachineHandover := func(vmi *virtv1.VirtualMachineInstance) {
 		vmiInterface.EXPECT().Update(gomock.Any()).Do(func(arg interface{}) {
 			Expect(arg.(*virtv1.VirtualMachineInstance).Status.Phase).To(Equal(virtv1.Scheduled))
@@ -691,6 +721,82 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 
 	})
 
+	Context("with network-status annotation", func() {
+		const (
+			defaultNetworkName = "default"
+			sriovNetworkName   = "network1"
+			netAttachDefName   = "default/nad1"
+			selectedPCIAddress = "0000:04:02.5"
+		)
+
+		It("should not patch network-pci-map when no SR-IOV networks exist", func() {
+			vmi := NewPendingVirtualMachine("testvmi")
+			vmi.Status.Phase = virtv1.Running
+			vmi = addDefaultNetwork(vmi, defaultNetworkName)
+			pod := NewPodForVirtualMachine(vmi, k8sv1.PodRunning)
+			addVirtualMachine(vmi)
+			podFeeder.Add(pod)
+			addActivePods(vmi, pod.UID, "")
+			pod.Annotations[networkv1.NetworkStatusAnnot] = `
+			[
+			{
+			"name": "kindnet",
+			"interface": "eth0",
+			"ips": [
+			  "10.244.2.131"
+			],
+			"mac": "82:cf:7c:98:43:7e",
+			"default": true,
+			"dns": {}
+			}
+			]`
+
+			vmiInterface.EXPECT().Patch(vmi.Name, types.JSONPatchType, gomock.Any(), &metav1.PatchOptions{}).Return(vmi, nil)
+			controller.Execute()
+			Expect(pod.Annotations).ToNot(HaveKey(sriov.NetworkPCIMapAnnot))
+		})
+		It("should patch network-pci-map when SR-IOV networks exist", func() {
+			vmi := NewPendingVirtualMachine("testvmi")
+			vmi.Status.Phase = virtv1.Running
+			vmi = addDefaultNetwork(vmi, defaultNetworkName)
+			vmi = addSRIOVNetwork(vmi, sriovNetworkName, netAttachDefName)
+			pod := NewPodForVirtualMachine(vmi, k8sv1.PodRunning)
+			addVirtualMachine(vmi)
+			podFeeder.Add(pod)
+			addActivePods(vmi, pod.UID, "")
+			pod.Annotations[networkv1.NetworkStatusAnnot] = `
+			[
+			{
+			"name": "kindnet",
+			"interface": "eth0",
+			"ips": [
+			  "10.244.2.131"
+			],
+			"mac": "82:cf:7c:98:43:7e",
+			"default": true,
+			"dns": {}
+			},
+			{
+			"name": "` + netAttachDefName + `",
+			"interface": "net1",
+			"dns": {},
+			"device-info": {
+			  "type": "pci",
+			  "version": "1.0.0",
+			  "pci": {
+			    "pci-address": "` + selectedPCIAddress + `"
+			  }
+			}
+			}
+			]`
+
+			vmiInterface.EXPECT().Patch(vmi.Name, types.JSONPatchType, gomock.Any(), &metav1.PatchOptions{}).Return(vmi, nil)
+			prependInjectPodPatch(pod)
+			controller.Execute()
+			Expect(pod.Annotations).To(HaveKeyWithValue(sriov.NetworkPCIMapAnnot, `{"`+sriovNetworkName+`":"`+selectedPCIAddress+`"}`))
+		})
+	})
+
 	Context("On valid VirtualMachineInstance given", func() {
 		It("should create a corresponding Pod on VirtualMachineInstance creation", func() {
 			vmi := NewPendingVirtualMachine("testvmi")
@@ -2765,7 +2871,7 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 				var vmi *virtv1.VirtualMachineInstance
 				vmiInterface.EXPECT().Update(gomock.Any()).Do(func(arg interface{}) {
 					vmi = arg.(*virtv1.VirtualMachineInstance)
-					Expect(topology.IsManualTSCFrequencyRequired(vmi)).To(BeTrue())
+					Expect(topology.AreTSCFrequencyTopologyHintsDefined(vmi)).To(BeTrue())
 				}).Return(vmi, nil)
 			}
 
@@ -2790,16 +2896,44 @@ var _ = Describe("VirtualMachineInstance watcher", func() {
 				runController(vmi)
 			})
 
-			It("HyperV reenlightenment is enabled", func() {
-				vmi := NewPendingVirtualMachine("testvmi")
-				vmi.Spec.Domain.Features = &v1.Features{
-					Hyperv: &v1.FeatureHyperv{
-						Reenlightenment: &v1.FeatureState{Enabled: pointer.Bool(true)},
-					},
-				}
+			Context("HyperV reenlightenment is enabled", func() {
+				var vmi *v1.VirtualMachineInstance
+
+				BeforeEach(func() {
+					vmi = NewPendingVirtualMachine("testvmi")
+					vmi.Spec.Domain.Features = &v1.Features{
+						Hyperv: &v1.FeatureHyperv{
+							Reenlightenment: &v1.FeatureState{Enabled: pointer.Bool(true)},
+						},
+					}
+				})
+
+				When("TSC frequency is exposed", func() {
+					It("topology hints need to be set", func() {
+						expectTopologyHintsUpdate()
+						runController(vmi)
+
+						testutils.ExpectEvent(recorder, SuccessfulCreatePodReason)
+					})
+				})
+
+				When("TSC frequency is not exposed", func() {
+					unexposeTscFrequency := func(requirement topology.TscFrequencyRequirementType) {
+						mockHinter := topology.NewMockHinter(ctrl)
+						mockHinter.EXPECT().TopologyHintsForVMI(gomock.Any()).Return(nil, requirement, fmt.Errorf("tsc frequency is not exposed on the cluster")).AnyTimes()
+						mockHinter.EXPECT().IsTscFrequencyRequiredForBoot(gomock.Any()).Return(requirement == topology.RequiredForBoot)
+						controller.topologyHinter = mockHinter
+					}
+
+					It("topology hints don't need to be set and VMI needs to be non-migratable", func() {
+						unexposeTscFrequency(topology.RequiredForMigration)
+						// Make sure no update occurs
+						runController(vmi)
+
+						testutils.ExpectEvent(recorder, SuccessfulCreatePodReason)
+					})
+				})
 
-				expectTopologyHintsUpdate()
-				runController(vmi)
 			})
 
 		})
@@ -2997,3 +3131,49 @@ func addActivePods(vmi *virtv1.VirtualMachineInstance, podUID types.UID, hostNam
 	}
 	return vmi
 }
+
+func addDefaultNetwork(vmi *virtv1.VirtualMachineInstance, networkName string) *virtv1.VirtualMachineInstance {
+	vmi.Spec.Domain.Devices.Interfaces = append(vmi.Spec.Domain.Devices.Interfaces, newMasqueradePrimaryInterface(networkName))
+	vmi.Spec.Networks = append(vmi.Spec.Networks, newMasqueradeDefaultNetwork(networkName))
+	return vmi
+}
+
+func addSRIOVNetwork(vmi *virtv1.VirtualMachineInstance, networkName, nadName string) *virtv1.VirtualMachineInstance {
+	vmi.Spec.Domain.Devices.Interfaces = append(vmi.Spec.Domain.Devices.Interfaces, newSRIOVInterface(networkName))
+	vmi.Spec.Networks = append(vmi.Spec.Networks, newMultusNetwork(networkName, nadName))
+	return vmi
+}
+
+func newSRIOVInterface(name string) virtv1.Interface {
+	return virtv1.Interface{
+		Name:                   name,
+		InterfaceBindingMethod: virtv1.InterfaceBindingMethod{SRIOV: &virtv1.InterfaceSRIOV{}},
+	}
+}
+
+func newMasqueradePrimaryInterface(name string) virtv1.Interface {
+	return virtv1.Interface{
+		Name:                   name,
+		InterfaceBindingMethod: virtv1.InterfaceBindingMethod{Masquerade: &virtv1.InterfaceMasquerade{}},
+	}
+}
+
+func newMasqueradeDefaultNetwork(name string) virtv1.Network {
+	return virtv1.Network{
+		Name: name,
+		NetworkSource: virtv1.NetworkSource{
+			Pod: &virtv1.PodNetwork{},
+		},
+	}
+}
+
+func newMultusNetwork(name, networkName string) virtv1.Network {
+	return virtv1.Network{
+		Name: name,
+		NetworkSource: virtv1.NetworkSource{
+			Multus: &virtv1.MultusNetwork{
+				NetworkName: networkName,
+			},
+		},
+	}
+}
diff --git a/pkg/virt-handler/BUILD.bazel b/pkg/virt-handler/BUILD.bazel
index 1e11678a097..3dfce8e53c2 100644
--- a/pkg/virt-handler/BUILD.bazel
+++ b/pkg/virt-handler/BUILD.bazel
@@ -30,6 +30,7 @@ go_library(
         "//pkg/util/hardware:go_default_library",
         "//pkg/util/migrations:go_default_library",
         "//pkg/virt-config:go_default_library",
+        "//pkg/virt-controller/watch/topology:go_default_library",
         "//pkg/virt-handler/cache:go_default_library",
         "//pkg/virt-handler/cgroup:go_default_library",
         "//pkg/virt-handler/cmd-client:go_default_library",
diff --git a/pkg/virt-handler/vm.go b/pkg/virt-handler/vm.go
index 8f63e25b651..4867c91a4b6 100644
--- a/pkg/virt-handler/vm.go
+++ b/pkg/virt-handler/vm.go
@@ -33,6 +33,8 @@ import (
 	"strings"
 	"time"
 
+	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
+
 	hotplugdisk "kubevirt.io/kubevirt/pkg/hotplug-disk"
 	"kubevirt.io/kubevirt/pkg/safepath"
 	"kubevirt.io/kubevirt/pkg/virt-handler/cgroup"
@@ -1365,6 +1367,10 @@ func (d *VirtualMachineController) calculateLiveMigrationCondition(vmi *v1.Virtu
 		return newNonMigratableCondition("VMI uses SEV", v1.VirtualMachineInstanceReasonSEVNotMigratable), isBlockMigration
 	}
 
+	if tscRequirement := topology.GetTscFrequencyRequirement(vmi); !topology.AreTSCFrequencyTopologyHintsDefined(vmi) && tscRequirement.Type == topology.RequiredForMigration {
+		return newNonMigratableCondition(tscRequirement.Reason, v1.VirtualMachineInstanceReasonNoTSCFrequencyMigratable), isBlockMigration
+	}
+
 	return &v1.VirtualMachineInstanceCondition{
 		Type:   v1.VirtualMachineInstanceIsMigratable,
 		Status: k8sv1.ConditionTrue,
diff --git a/pkg/virt-handler/vm_test.go b/pkg/virt-handler/vm_test.go
index 3065b3c389d..e6ab6f7b15f 100644
--- a/pkg/virt-handler/vm_test.go
+++ b/pkg/virt-handler/vm_test.go
@@ -2598,6 +2598,17 @@ var _ = Describe("VirtualMachineInstance", func() {
 			)
 		})
 
+		It("HyperV reenlightenment shouldn't be migratable when tsc frequency is missing", func() {
+			vmi := api2.NewMinimalVMI("testvmi")
+			vmi.Spec.Domain.Features = &v1.Features{Hyperv: &v1.FeatureHyperv{Reenlightenment: &v1.FeatureState{Enabled: pointer.Bool(true)}}}
+			vmi.Status.TopologyHints = nil
+
+			cond, _ := controller.calculateLiveMigrationCondition(vmi)
+			Expect(cond).ToNot(BeNil())
+			Expect(cond.Type).To(Equal(v1.VirtualMachineInstanceIsMigratable))
+			Expect(cond.Status).To(Equal(k8sv1.ConditionFalse))
+		})
+
 	})
 
 	Context("VirtualMachineInstance network status", func() {
diff --git a/pkg/virt-launcher/virtwrap/converter/converter.go b/pkg/virt-launcher/virtwrap/converter/converter.go
index 73250d64234..6e73d0a6376 100644
--- a/pkg/virt-launcher/virtwrap/converter/converter.go
+++ b/pkg/virt-launcher/virtwrap/converter/converter.go
@@ -35,12 +35,12 @@ import (
 	"strings"
 	"syscall"
 
+	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
+
 	"golang.org/x/sys/unix"
 
 	"kubevirt.io/kubevirt/pkg/virt-launcher/virtwrap/converter/vcpu"
 
-	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
-
 	"kubevirt.io/kubevirt/pkg/virt-controller/services"
 
 	k8sv1 "k8s.io/api/core/v1"
@@ -1708,17 +1708,6 @@ func Convert_v1_VirtualMachineInstance_To_api_Domain(vmi *v1.VirtualMachineInsta
 			}
 		}
 
-		// Make use of the tsc frequency topology hint
-		if topology.IsManualTSCFrequencyRequired(vmi) && topology.AreTSCFrequencyTopologyHintsDefined(vmi) {
-			freq := *vmi.Status.TopologyHints.TSCFrequency
-			clock := domain.Spec.Clock
-			if clock == nil {
-				clock = &api.Clock{}
-			}
-			clock.Timer = append(clock.Timer, api.Timer{Name: "tsc", Frequency: strconv.FormatInt(freq, 10)})
-			domain.Spec.Clock = clock
-		}
-
 		// Adjust guest vcpu config. Currently will handle vCPUs to pCPUs pinning
 		if vmi.IsCPUDedicated() {
 			err = vcpu.AdjustDomainForTopologyAndCPUSet(domain, vmi, c.Topology, c.CPUSet, useIOThreads)
@@ -1728,6 +1717,17 @@ func Convert_v1_VirtualMachineInstance_To_api_Domain(vmi *v1.VirtualMachineInsta
 		}
 	}
 
+	// Make use of the tsc frequency topology hint
+	if topology.IsManualTSCFrequencyRequired(vmi) && topology.AreTSCFrequencyTopologyHintsDefined(vmi) {
+		freq := *vmi.Status.TopologyHints.TSCFrequency
+		clock := domain.Spec.Clock
+		if clock == nil {
+			clock = &api.Clock{}
+		}
+		clock.Timer = append(clock.Timer, api.Timer{Name: "tsc", Frequency: strconv.FormatInt(freq, 10)})
+		domain.Spec.Clock = clock
+	}
+
 	domain.Spec.Devices.HostDevices = append(domain.Spec.Devices.HostDevices, c.GenericHostDevices...)
 	domain.Spec.Devices.HostDevices = append(domain.Spec.Devices.HostDevices, c.GPUHostDevices...)
 
diff --git a/pkg/virt-launcher/virtwrap/converter/converter_test.go b/pkg/virt-launcher/virtwrap/converter/converter_test.go
index cce54140a49..7a142d5ff21 100644
--- a/pkg/virt-launcher/virtwrap/converter/converter_test.go
+++ b/pkg/virt-launcher/virtwrap/converter/converter_test.go
@@ -3241,6 +3241,80 @@ var _ = Describe("Converter", func() {
 			Expect(domain.Spec.Devices.Interfaces[1].Rom.Enabled).To(Equal("no"))
 		})
 	})
+
+	Context("when TSC Frequency", func() {
+		var (
+			vmi *v1.VirtualMachineInstance
+			c   *ConverterContext
+		)
+
+		const fakeFrequency = 12345
+
+		BeforeEach(func() {
+			vmi = kvapi.NewMinimalVMI("testvmi")
+			v1.SetObjectDefaults_VirtualMachineInstance(vmi)
+			vmi.Status.TopologyHints = &v1.TopologyHints{TSCFrequency: pointer.Int64(fakeFrequency)}
+			c = &ConverterContext{
+				AllowEmulation: true,
+			}
+		})
+
+		expectTsc := func(domain *api.Domain, expectExists bool) {
+			Expect(domain).ToNot(BeNil())
+			if !expectExists && domain.Spec.Clock == nil {
+				return
+			}
+
+			Expect(domain.Spec.Clock).ToNot(BeNil())
+
+			found := false
+			for _, timer := range domain.Spec.Clock.Timer {
+				if timer.Name == "tsc" {
+					actualFrequency, err := strconv.Atoi(timer.Frequency)
+					Expect(err).ToNot(HaveOccurred(), "frequency cannot be converted into a number")
+					Expect(actualFrequency).To(Equal(fakeFrequency), "set frequency is incorrect")
+
+					found = true
+					break
+				}
+			}
+
+			expectationStr := "exist"
+			if !expectExists {
+				expectationStr = "not " + expectationStr
+			}
+			Expect(found).To(Equal(expectExists), fmt.Sprintf("domain TSC frequency is expected to %s", expectationStr))
+		}
+
+		Context("is required because VMI is using", func() {
+			It("hyperV reenlightenment", func() {
+				vmi.Spec.Domain.Features = &v1.Features{
+					Hyperv: &v1.FeatureHyperv{
+						Reenlightenment: &v1.FeatureState{Enabled: pointer.Bool(true)},
+					},
+				}
+
+				domain := vmiToDomain(vmi, c)
+				expectTsc(domain, true)
+			})
+
+			It("invtsc CPU feature", func() {
+				vmi.Spec.Domain.CPU = &v1.CPU{
+					Features: []v1.CPUFeature{
+						{Name: "invtsc", Policy: "require"},
+					},
+				}
+
+				domain := vmiToDomain(vmi, c)
+				expectTsc(domain, true)
+			})
+		})
+
+		It("is not required", func() {
+			domain := vmiToDomain(vmi, c)
+			expectTsc(domain, false)
+		})
+	})
 })
 
 var _ = Describe("disk device naming", func() {
diff --git a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/BUILD.bazel b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/BUILD.bazel
index 4e6ef235253..7fc3419d436 100644
--- a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/BUILD.bazel
+++ b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/BUILD.bazel
@@ -5,6 +5,7 @@ go_library(
     srcs = [
         "hostdev.go",
         "pcipool.go",
+        "pcipool_netstatus.go",
     ],
     importpath = "kubevirt.io/kubevirt/pkg/virt-launcher/virtwrap/device/hostdevice/sriov",
     visibility = ["//visibility:public"],
@@ -16,6 +17,7 @@ go_library(
         "//pkg/virt-launcher/virtwrap/device/hostdevice:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
         "//staging/src/kubevirt.io/client-go/log:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
     ],
 )
 
@@ -23,6 +25,7 @@ go_test(
     name = "go_default_test",
     srcs = [
         "hostdev_test.go",
+        "pcipool_netstatus_test.go",
         "pcipool_test.go",
         "sriov_suite_test.go",
     ],
diff --git a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/hostdev.go b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/hostdev.go
index f7b5231eb13..e5e0d1c0e8e 100644
--- a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/hostdev.go
+++ b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/hostdev.go
@@ -20,10 +20,16 @@
 package sriov
 
 import (
+	"errors"
 	"fmt"
+	"os"
+	"path"
 	"time"
 
+	"k8s.io/apimachinery/pkg/util/wait"
+
 	v1 "kubevirt.io/api/core/v1"
+	"kubevirt.io/client-go/log"
 
 	"kubevirt.io/kubevirt/pkg/network/sriov"
 	"kubevirt.io/kubevirt/pkg/network/vmispec"
@@ -34,7 +40,49 @@ import (
 
 func CreateHostDevices(vmi *v1.VirtualMachineInstance) ([]api.HostDevice, error) {
 	SRIOVInterfaces := vmispec.FilterSRIOVInterfaces(vmi.Spec.Domain.Devices.Interfaces)
-	return CreateHostDevicesFromIfacesAndPool(SRIOVInterfaces, NewPCIAddressPool(SRIOVInterfaces))
+	netStatusPath := path.Join(sriov.MountPath, sriov.VolumePath)
+	pciAddressPoolWithNetworkStatus, err := newPCIAddressPoolWithNetworkStatusFromFile(netStatusPath)
+	if err != nil {
+		return nil, err
+	}
+	if pciAddressPoolWithNetworkStatus.Len() == 0 {
+		log.Log.Object(vmi).Warningf("found no SR-IOV networks to PCI-Address mapping. fall back to resource address pool")
+		return CreateHostDevicesFromIfacesAndPool(SRIOVInterfaces, NewPCIAddressPool(SRIOVInterfaces))
+	}
+
+	return CreateHostDevicesFromIfacesAndPool(SRIOVInterfaces, pciAddressPoolWithNetworkStatus)
+}
+
+// newPCIAddressPoolWithNetworkStatusFromFile polls the given file path until populated, then uses it to create the
+// PCI-Address Pool.
+// possible return values are:
+// - file populated - return PCI-Address Pool using the data in file.
+// - file empty post-polling (timeout) - return err to fail SyncVMI.
+// - other error reading file (i.e. file not exist) - return no error but PCIAddressWithNetworkStatusPool.Len() will return 0.
+func newPCIAddressPoolWithNetworkStatusFromFile(path string) (*PCIAddressWithNetworkStatusPool, error) {
+	networkPCIMapBytes, err := readFileUntilNotEmpty(path)
+	if err != nil {
+		if isFileEmptyAfterTimeout(err, networkPCIMapBytes) {
+			return nil, err
+		}
+		return nil, nil
+	}
+
+	return NewPCIAddressPoolWithNetworkStatus(networkPCIMapBytes)
+}
+
+func readFileUntilNotEmpty(networkPCIMapPath string) ([]byte, error) {
+	var networkPCIMapBytes []byte
+	err := wait.PollImmediate(100*time.Millisecond, time.Second, func() (bool, error) {
+		var err error
+		networkPCIMapBytes, err = os.ReadFile(networkPCIMapPath)
+		return len(networkPCIMapBytes) > 0, err
+	})
+	return networkPCIMapBytes, err
+}
+
+func isFileEmptyAfterTimeout(err error, data []byte) bool {
+	return errors.Is(err, wait.ErrWaitTimeout) && len(data) == 0
 }
 
 func CreateHostDevicesFromIfacesAndPool(ifaces []v1.Interface, pool hostdevice.AddressPooler) ([]api.HostDevice, error) {
diff --git a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus.go b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus.go
new file mode 100644
index 00000000000..4422b26ccf8
--- /dev/null
+++ b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus.go
@@ -0,0 +1,66 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright 2022 Red Hat, Inc.
+ *
+ */
+
+package sriov
+
+import (
+	"encoding/json"
+	"fmt"
+)
+
+type PCIAddressWithNetworkStatusPool struct {
+	networkPCIMap map[string]string
+}
+
+// NewPCIAddressPoolWithNetworkStatus creates a PCI address pool based on the networkPciMapPath volume
+func NewPCIAddressPoolWithNetworkStatus(networkPCIMapBytes []byte) (*PCIAddressWithNetworkStatusPool, error) {
+	pool := &PCIAddressWithNetworkStatusPool{}
+
+	var networkPciMap map[string]string
+	err := json.Unmarshal(networkPCIMapBytes, &networkPciMap)
+	if err != nil {
+		return nil, fmt.Errorf("failed to unmarshal network-pci map %w", err)
+	}
+
+	pool.networkPCIMap = networkPciMap
+	return pool, nil
+}
+
+// Len returns the length of the pool.
+func (p *PCIAddressWithNetworkStatusPool) Len() int {
+	if p == nil {
+		return 0
+	}
+	return len(p.networkPCIMap)
+}
+
+// Pop gets the next PCI address available to a particular SR-IOV network. The
+// function makes sure that the allocated address is not allocated to other networks.
+func (p *PCIAddressWithNetworkStatusPool) Pop(networkName string) (string, error) {
+	pciAddress, exists := p.networkPCIMap[networkName]
+	if !exists {
+		return "", fmt.Errorf("PCI-Address for SR-IOV network %q not found", networkName)
+	}
+
+	if pciAddress == "" {
+		return "", fmt.Errorf("failed to allocate SR-IOV PCI address for network %q", networkName)
+	}
+	delete(p.networkPCIMap, networkName)
+	return pciAddress, nil
+}
diff --git a/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus_test.go b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus_test.go
new file mode 100644
index 00000000000..c0ccdbe779b
--- /dev/null
+++ b/pkg/virt-launcher/virtwrap/device/hostdevice/sriov/pcipool_netstatus_test.go
@@ -0,0 +1,79 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright 2021 Red Hat, Inc.
+ *
+ */
+
+package sriov_test
+
+import (
+	"encoding/json"
+	"errors"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	sriovhostdev "kubevirt.io/kubevirt/pkg/virt-launcher/virtwrap/device/hostdevice/sriov"
+)
+
+var _ = Describe("SRIOV PCI address pool with network-pci-map", func() {
+	var emptyFileBytes []byte
+	emptyNetworkPCIMapBytes := []byte("{}")
+	networkPCIMapWithThreeNetworks := []byte(
+		`{"network1":"0000:04:02.5","network2":"0000:04:02.7","network3":"0000:04:02.8"}`)
+
+	It("should fail to create the pool when network-pci-map file is empty", func() {
+		pool, err := sriovhostdev.NewPCIAddressPoolWithNetworkStatus(emptyFileBytes)
+
+		var expectedTypeError *json.SyntaxError
+		Expect(errors.As(err, &expectedTypeError)).To(BeTrue())
+		Expect(pool).To(BeNil())
+	})
+
+	It("should create a pool with zero length when network-pci-map file holds empty map", func() {
+		pool, err := sriovhostdev.NewPCIAddressPoolWithNetworkStatus(emptyNetworkPCIMapBytes)
+
+		Expect(err).ToNot(HaveOccurred())
+		Expect(pool.Len()).To(BeZero())
+	})
+
+	It("should fail to pop a pci-address from the pool when network-pci-map file has valid data but requested network is not in pool", func() {
+		pool, err := sriovhostdev.NewPCIAddressPoolWithNetworkStatus(networkPCIMapWithThreeNetworks)
+		Expect(err).ToNot(HaveOccurred())
+
+		_, err = pool.Pop("foo")
+		Expect(err).To(HaveOccurred())
+	})
+
+	It("should succeed to pop a pci-address from the pool when network-pci map is valid", func() {
+		pool, err := sriovhostdev.NewPCIAddressPoolWithNetworkStatus(networkPCIMapWithThreeNetworks)
+		Expect(err).ToNot(HaveOccurred())
+
+		expectedNetworkToPCIMap := map[string]string{
+			"network1": "0000:04:02.5",
+			"network2": "0000:04:02.7",
+			"network3": "0000:04:02.8",
+		}
+		for requestedNetwork, expectedPciAddress := range expectedNetworkToPCIMap {
+			By("check pop succeeds to retrieve the PCI Address")
+			Expect(pool.Pop(requestedNetwork)).To(Equal(expectedPciAddress))
+
+			By("check pop fails to retrieve from the network after it was already popped")
+			_, err := pool.Pop(requestedNetwork)
+			Expect(err).To(HaveOccurred())
+		}
+	})
+})
diff --git a/pkg/virt-operator/resource/generate/components/daemonsets.go b/pkg/virt-operator/resource/generate/components/daemonsets.go
index b6e9426d172..5984ec5c939 100644
--- a/pkg/virt-operator/resource/generate/components/daemonsets.go
+++ b/pkg/virt-operator/resource/generate/components/daemonsets.go
@@ -22,10 +22,12 @@ const (
 	kubeletPodsPath = "/var/lib/kubelet/pods"
 )
 
-func NewHandlerDaemonSet(namespace string, repository string, imagePrefix string, version string, launcherVersion string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, migrationNetwork *string, verbosity string, extraEnv map[string]string) (*appsv1.DaemonSet, error) {
+func NewHandlerDaemonSet(namespace string, imageName string, repository string, imagePrefix string, version string, launcherImage string, launcherVersion string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, migrationNetwork *string, verbosity string, extraEnv map[string]string) (*appsv1.DaemonSet, error) {
 
 	deploymentName := VirtHandlerName
-	imageName := fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	if imageName == "" {
+		imageName = fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	}
 	env := operatorutil.NewEnvVarMap(extraEnv)
 	podTemplateSpec, err := newPodTemplateSpec(deploymentName, imageName, repository, version, productName, productVersion, productComponent, pullPolicy, nil, env)
 	if err != nil {
@@ -83,13 +85,16 @@ func NewHandlerDaemonSet(namespace string, repository string, imagePrefix string
 	// nodelabeller currently only support x86
 	if virtconfig.IsAMD64(runtime.GOARCH) {
 		launcherVersion = AddVersionSeparatorPrefix(launcherVersion)
+		if launcherImage == "" {
+			launcherImage = fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-launcher", launcherVersion)
+		}
 		pod.InitContainers = []corev1.Container{
 			{
 				Command: []string{
 					"/bin/sh",
 					"-c",
 				},
-				Image: fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-launcher", launcherVersion),
+				Image: launcherImage,
 				Name:  "virt-launcher",
 				Args: []string{
 					"node-labeller.sh",
diff --git a/pkg/virt-operator/resource/generate/components/deployments.go b/pkg/virt-operator/resource/generate/components/deployments.go
index b5176018dee..8ad56215acd 100644
--- a/pkg/virt-operator/resource/generate/components/deployments.go
+++ b/pkg/virt-operator/resource/generate/components/deployments.go
@@ -302,10 +302,12 @@ func newPodAntiAffinity(key, topologyKey string, operator metav1.LabelSelectorOp
 	}
 }
 
-func NewApiServerDeployment(namespace string, repository string, imagePrefix string, version string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
+func NewApiServerDeployment(namespace string, imageName string, repository string, imagePrefix string, version string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
 	podAntiAffinity := newPodAntiAffinity(kubevirtLabelKey, kubernetesHostnameTopologyKey, metav1.LabelSelectorOpIn, []string{VirtAPIName})
 	deploymentName := VirtAPIName
-	imageName := fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	if imageName == "" {
+		imageName = fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	}
 	env := operatorutil.NewEnvVarMap(extraEnv)
 	deployment, err := newBaseDeployment(deploymentName, imageName, namespace, repository, version, productName, productVersion, productComponent, pullPolicy, podAntiAffinity, env)
 	if err != nil {
@@ -372,10 +374,20 @@ func NewApiServerDeployment(namespace string, repository string, imagePrefix str
 	return deployment, nil
 }
 
-func NewControllerDeployment(namespace string, repository string, imagePrefix string, controllerVersion string, launcherVersion string, exportServerVersion string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
+func NewControllerDeployment(namespace string, imageName string, repository string, imagePrefix string, controllerVersion string, launcherImage string, launcherVersion string, exporterImage string, exportServerVersion string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
 	podAntiAffinity := newPodAntiAffinity(kubevirtLabelKey, kubernetesHostnameTopologyKey, metav1.LabelSelectorOpIn, []string{VirtControllerName})
 	deploymentName := VirtControllerName
-	imageName := fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	if imageName == "" {
+		imageName = fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	}
+	launcherVersion = AddVersionSeparatorPrefix(launcherVersion)
+	exportServerVersion = AddVersionSeparatorPrefix(exportServerVersion)
+	if launcherImage == "" {
+		launcherImage = fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-launcher", launcherVersion)
+	}
+	if exporterImage == "" {
+		exporterImage = fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-exportserver", exportServerVersion)
+	}
 	env := operatorutil.NewEnvVarMap(extraEnv)
 	deployment, err := newBaseDeployment(deploymentName, imageName, namespace, repository, controllerVersion, productName, productVersion, productComponent, pullPolicy, podAntiAffinity, env)
 	if err != nil {
@@ -388,18 +400,15 @@ func NewControllerDeployment(namespace string, repository string, imagePrefix st
 		RunAsNonRoot: boolPtr(true),
 	}
 
-	launcherVersion = AddVersionSeparatorPrefix(launcherVersion)
-	exportServerVersion = AddVersionSeparatorPrefix(exportServerVersion)
-
 	container := &deployment.Spec.Template.Spec.Containers[0]
 	container.Command = []string{
 		VirtControllerName,
 	}
 	container.Args = []string{
 		"--launcher-image",
-		fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-launcher", launcherVersion),
+		launcherImage,
 		"--exporter-image",
-		fmt.Sprintf("%s/%s%s%s", repository, imagePrefix, "virt-exportserver", exportServerVersion),
+		exporterImage,
 		portName,
 		"8443",
 		"-v",
@@ -624,10 +633,12 @@ func NewOperatorDeployment(namespace string, repository string, imagePrefix stri
 	return deployment, nil
 }
 
-func NewExportProxyDeployment(namespace string, repository string, imagePrefix string, version string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
+func NewExportProxyDeployment(namespace string, imageName string, repository string, imagePrefix string, version string, productName string, productVersion string, productComponent string, pullPolicy corev1.PullPolicy, verbosity string, extraEnv map[string]string) (*appsv1.Deployment, error) {
 	podAntiAffinity := newPodAntiAffinity(kubevirtLabelKey, kubernetesHostnameTopologyKey, metav1.LabelSelectorOpIn, []string{VirtAPIName})
 	deploymentName := VirtExportProxyName
-	imageName := fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	if imageName == "" {
+		imageName = fmt.Sprintf("%s%s", imagePrefix, deploymentName)
+	}
 	env := operatorutil.NewEnvVarMap(extraEnv)
 	deployment, err := newBaseDeployment(deploymentName, imageName, namespace, repository, version, productName, productVersion, productComponent, pullPolicy, podAntiAffinity, env)
 	if err != nil {
diff --git a/pkg/virt-operator/resource/generate/install/strategy.go b/pkg/virt-operator/resource/generate/install/strategy.go
index e0710665ea2..2fe913a542a 100644
--- a/pkg/virt-operator/resource/generate/install/strategy.go
+++ b/pkg/virt-operator/resource/generate/install/strategy.go
@@ -493,13 +493,13 @@ func GenerateCurrentInstallStrategy(config *operatorutil.KubeVirtDeploymentConfi
 	strategy.services = append(strategy.services, components.NewApiServerService(config.GetNamespace()))
 	strategy.services = append(strategy.services, components.NewOperatorWebhookService(operatorNamespace))
 	strategy.services = append(strategy.services, components.NewExportProxyService(config.GetNamespace()))
-	apiDeployment, err := components.NewApiServerDeployment(config.GetNamespace(), config.GetImageRegistry(), config.GetImagePrefix(), config.GetApiVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
+	apiDeployment, err := components.NewApiServerDeployment(config.GetNamespace(), config.VirtApiImage, config.GetImageRegistry(), config.GetImagePrefix(), config.GetApiVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
 	if err != nil {
 		return nil, fmt.Errorf("error generating virt-apiserver deployment %v", err)
 	}
 	strategy.deployments = append(strategy.deployments, apiDeployment)
 
-	controller, err := components.NewControllerDeployment(config.GetNamespace(), config.GetImageRegistry(), config.GetImagePrefix(), config.GetControllerVersion(), config.GetLauncherVersion(), config.GetExportServerVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
+	controller, err := components.NewControllerDeployment(config.GetNamespace(), config.VirtControllerImage, config.GetImageRegistry(), config.GetImagePrefix(), config.GetControllerVersion(), config.VirtLauncherImage, config.GetLauncherVersion(), config.VirtExportServerImage, config.GetExportServerVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
 	if err != nil {
 		return nil, fmt.Errorf("error generating virt-controller deployment %v", err)
 	}
@@ -507,13 +507,13 @@ func GenerateCurrentInstallStrategy(config *operatorutil.KubeVirtDeploymentConfi
 
 	strategy.configMaps = append(strategy.configMaps, components.NewCAConfigMaps(operatorNamespace)...)
 
-	exportProxyDeployment, err := components.NewExportProxyDeployment(config.GetNamespace(), config.GetImageRegistry(), config.GetImagePrefix(), config.GetExportProxyVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
+	exportProxyDeployment, err := components.NewExportProxyDeployment(config.GetNamespace(), config.VirtExportProxyImage, config.GetImageRegistry(), config.GetImagePrefix(), config.GetExportProxyVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetVerbosity(), config.GetExtraEnv())
 	if err != nil {
 		return nil, fmt.Errorf("error generating export proxy deployment %v", err)
 	}
 	strategy.deployments = append(strategy.deployments, exportProxyDeployment)
 
-	handler, err := components.NewHandlerDaemonSet(config.GetNamespace(), config.GetImageRegistry(), config.GetImagePrefix(), config.GetHandlerVersion(), config.GetLauncherVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetMigrationNetwork(), config.GetVerbosity(), config.GetExtraEnv())
+	handler, err := components.NewHandlerDaemonSet(config.GetNamespace(), config.VirtHandlerImage, config.GetImageRegistry(), config.GetImagePrefix(), config.GetHandlerVersion(), config.VirtLauncherImage, config.GetLauncherVersion(), productName, productVersion, productComponent, config.GetImagePullPolicy(), config.GetMigrationNetwork(), config.GetVerbosity(), config.GetExtraEnv())
 	if err != nil {
 		return nil, fmt.Errorf("error generating virt-handler deployment %v", err)
 	}
diff --git a/pkg/virt-operator/resource/generate/rbac/controller.go b/pkg/virt-operator/resource/generate/rbac/controller.go
index 84858515b95..8dd5d520e8e 100644
--- a/pkg/virt-operator/resource/generate/rbac/controller.go
+++ b/pkg/virt-operator/resource/generate/rbac/controller.go
@@ -177,7 +177,7 @@ func newControllerClusterRole() *rbacv1.ClusterRole {
 					"pods", "configmaps", "endpoints", "services",
 				},
 				Verbs: []string{
-					"get", "list", "watch", "delete", "update", "create",
+					"get", "list", "watch", "delete", "update", "create", "patch",
 				},
 			},
 			{
diff --git a/pkg/virt-operator/util/config.go b/pkg/virt-operator/util/config.go
index 33e4ffbb69d..e29f43a6d9f 100644
--- a/pkg/virt-operator/util/config.go
+++ b/pkg/virt-operator/util/config.go
@@ -39,7 +39,15 @@ import (
 
 const (
 	// Name of env var containing the operator's image name
-	OperatorImageEnvName          = "OPERATOR_IMAGE"
+	OperatorImageEnvName = "OPERATOR_IMAGE"
+
+	VirtApiImageEnvName           = "VIRT_API_IMAGE"
+	VirtControllerImageEnvName    = "VIRT_CONTROLLER_IMAGE"
+	VirtHandlerImageEnvName       = "VIRT_HANDLER_IMAGE"
+	VirtLauncherImageEnvName      = "VIRT_LAUNCHER_IMAGE"
+	VirtExportProxyImageEnvName   = "VIRT_EXPORTPROXY_IMAGE"
+	VirtExportServerImageEnvName  = "VIRT_EXPORTSERVER_IMAGE"
+	GsEnvImageName                = "GS_IMAGE"
 	VirtApiShasumEnvName          = "VIRT_API_SHASUM"
 	VirtControllerShasumEnvName   = "VIRT_CONTROLLER_SHASUM"
 	VirtHandlerShasumEnvName      = "VIRT_HANDLER_SHASUM"
@@ -108,6 +116,16 @@ type KubeVirtDeploymentConfig struct {
 	// used on the KubeVirt CR status and on annotations, and for determining up-/downgrade path, even when using shasums for the images
 	KubeVirtVersion string `json:"kubeVirtVersion,omitempty" optional:"true"`
 
+	// the images names of every image we use
+	VirtOperatorImage     string `json:"virtOperatorImage,omitempty" optional:"true"`
+	VirtApiImage          string `json:"virtApiImage,omitempty" optional:"true"`
+	VirtControllerImage   string `json:"virtControllerImage,omitempty" optional:"true"`
+	VirtHandlerImage      string `json:"virtHandlerImage,omitempty" optional:"true"`
+	VirtLauncherImage     string `json:"virtLauncherImage,omitempty" optional:"true"`
+	VirtExportProxyImage  string `json:"virtExportProxyImage,omitempty" optional:"true"`
+	VirtExportServerImage string `json:"virtExportServerImage,omitempty" optional:"true"`
+	GsImage               string `json:"gsImage,omitempty" optional:"true"`
+
 	// the shasums of every image we use
 	VirtOperatorSha     string `json:"virtOperatorSha,omitempty" optional:"true"`
 	VirtApiSha          string `json:"virtApiSha,omitempty" optional:"true"`
@@ -246,7 +264,17 @@ func getConfig(registry, tag, namespace string, additionalProperties map[string]
 
 	passthroughEnv := GetPassthroughEnv()
 
-	config := newDeploymentConfigWithTag(registry, imagePrefix, tag, namespace, additionalProperties, passthroughEnv)
+	// get images names
+	operatorImage := os.Getenv(OperatorImageEnvName)
+	apiImage := os.Getenv(VirtApiImageEnvName)
+	controllerImage := os.Getenv(VirtControllerImageEnvName)
+	handlerImage := os.Getenv(VirtHandlerImageEnvName)
+	launcherImage := os.Getenv(VirtLauncherImageEnvName)
+	exportProxyImage := os.Getenv(VirtExportProxyImageEnvName)
+	exportServerImage := os.Getenv(VirtExportServerImageEnvName)
+	gsImage := os.Getenv(GsEnvImageName)
+
+	config := newDeploymentConfigWithTag(registry, imagePrefix, tag, operatorImage, apiImage, controllerImage, handlerImage, launcherImage, exportProxyImage, exportServerImage, gsImage, namespace, additionalProperties, passthroughEnv)
 	if skipShasums {
 		return config
 	}
@@ -309,14 +337,22 @@ func GetPassthroughEnv() map[string]string {
 	return passthroughEnv
 }
 
-func newDeploymentConfigWithTag(registry, imagePrefix, tag, namespace string, kvSpec, passthroughEnv map[string]string) *KubeVirtDeploymentConfig {
+func newDeploymentConfigWithTag(registry, imagePrefix, tag, operatorImage, apiImage, controllerImage, handlerImage, launcherImage, exportProxyImage, exportServerImage, gsImage, namespace string, kvSpec, passthroughEnv map[string]string) *KubeVirtDeploymentConfig {
 	c := &KubeVirtDeploymentConfig{
-		Registry:             registry,
-		ImagePrefix:          imagePrefix,
-		KubeVirtVersion:      tag,
-		Namespace:            namespace,
-		AdditionalProperties: kvSpec,
-		PassthroughEnvVars:   passthroughEnv,
+		Registry:              registry,
+		ImagePrefix:           imagePrefix,
+		KubeVirtVersion:       tag,
+		VirtOperatorImage:     operatorImage,
+		VirtApiImage:          apiImage,
+		VirtControllerImage:   controllerImage,
+		VirtHandlerImage:      handlerImage,
+		VirtLauncherImage:     launcherImage,
+		VirtExportProxyImage:  exportProxyImage,
+		VirtExportServerImage: exportServerImage,
+		GsImage:               gsImage,
+		Namespace:             namespace,
+		AdditionalProperties:  kvSpec,
+		PassthroughEnvVars:    passthroughEnv,
 	}
 	c.generateInstallStrategyID()
 	return c
diff --git a/pkg/virt-operator/util/config_test.go b/pkg/virt-operator/util/config_test.go
index e5e2d04e0ec..0f5fabc4905 100644
--- a/pkg/virt-operator/util/config_test.go
+++ b/pkg/virt-operator/util/config_test.go
@@ -134,6 +134,41 @@ var _ = Describe("Operator Config", func() {
 			false, false),
 	)
 
+	DescribeTable("Read imageName", func(image string, envVersions *KubeVirtDeploymentConfig, valid bool) {
+		os.Setenv(OperatorImageEnvName, image)
+
+		os.Unsetenv(VirtApiShasumEnvName)
+		os.Unsetenv(VirtControllerShasumEnvName)
+		os.Unsetenv(VirtHandlerShasumEnvName)
+		os.Unsetenv(VirtLauncherShasumEnvName)
+		os.Unsetenv(KubeVirtVersionEnvName)
+		os.Setenv(VirtApiImageEnvName, "a/kubevirt:api")
+		os.Setenv(VirtControllerImageEnvName, "a/kubevirt:controller")
+		os.Setenv(VirtHandlerImageEnvName, "a/kubevirt:handler")
+		os.Setenv(VirtLauncherImageEnvName, "a/kubevirt:launcher")
+
+		err := VerifyEnv()
+		if valid {
+			Expect(err).ToNot(HaveOccurred())
+		} else {
+			Expect(err).To(HaveOccurred())
+		}
+
+		parsedConfig, err := GetConfigFromEnv()
+		Expect(err).ToNot(HaveOccurred())
+
+		Expect(parsedConfig.VirtApiImage).To(Equal("a/kubevirt:api"), "api image should match")
+		Expect(parsedConfig.VirtControllerImage).To(Equal("a/kubevirt:controller"), "controller image should match")
+		Expect(parsedConfig.VirtHandlerImage).To(Equal("a/kubevirt:handler"), "handler image should match")
+		Expect(parsedConfig.VirtLauncherImage).To(Equal("a/kubevirt:launcher"), "launcher image should match")
+
+	},
+		//Entry("with all images names given", "a/kubevirt:operator",
+		Entry("with all images names given", "kubevirt/virt-operator@sha256:operator",
+			getConfig("kubevirt", "v123"),
+			true),
+	)
+
 	Describe("GetPassthroughEnv()", func() {
 		It("should eturn environment variables matching the passthrough prefix (and only those vars)", func() {
 			realKey := rand.String(10)
diff --git a/staging/src/kubevirt.io/api/core/v1/types.go b/staging/src/kubevirt.io/api/core/v1/types.go
index a0975c877ff..4b901f6bcf8 100644
--- a/staging/src/kubevirt.io/api/core/v1/types.go
+++ b/staging/src/kubevirt.io/api/core/v1/types.go
@@ -473,6 +473,8 @@ const (
 	VirtualMachineInstanceReasonHostDeviceNotMigratable = "HostDeviceNotLiveMigratable"
 	// Reason means that VMI is not live migratable because it uses Secure Encrypted Virtualization (SEV)
 	VirtualMachineInstanceReasonSEVNotMigratable = "SEVNotLiveMigratable"
+	// Reason means that VMI is not live migratable because it uses HyperV Reenlightenment while TSC Frequency is not available
+	VirtualMachineInstanceReasonNoTSCFrequencyMigratable = "NoTSCFrequencyNotLiveMigratable"
 )
 
 const (
diff --git a/tests/network/sriov.go b/tests/network/sriov.go
index 7b29e2ce0bf..c1f66f20d2d 100644
--- a/tests/network/sriov.go
+++ b/tests/network/sriov.go
@@ -64,6 +64,8 @@ const (
 const (
 	sriovnet1           = "sriov"
 	sriovnet2           = "sriov2"
+	sriovnet3           = "sriov3"
+	sriovnet4           = "sriov4"
 	sriovnetLinkEnabled = "sriov-linked"
 )
 
@@ -410,6 +412,38 @@ var _ = Describe("[Serial]SRIOV", func() {
 		})
 	})
 
+	Context("Connected to multiple SRIOV networks", func() {
+		sriovNetworks := []string{sriovnet1, sriovnet2, sriovnet3, sriovnet4}
+		BeforeEach(func() {
+			for _, sriovNetwork := range sriovNetworks {
+				Expect(createSriovNetworkAttachmentDefinition(sriovNetwork, util.NamespaceTestDefault, sriovConfNAD)).To(Succeed(), shouldCreateNetwork)
+			}
+		})
+
+		It("should correctly plug all the interfaces based on the specified MAC and (guest) PCI addresses", func() {
+			macAddressTemplate := "de:ad:00:be:ef:%02d"
+			pciAddressTemplate := "0000:2%d:00.0"
+			vmi := newSRIOVVmi(sriovNetworks, defaultCloudInitNetworkData())
+			for i := range sriovNetworks {
+				secondaryInterfaceIdx := i + 1
+				vmi.Spec.Domain.Devices.Interfaces[secondaryInterfaceIdx].MacAddress = fmt.Sprintf(macAddressTemplate, secondaryInterfaceIdx)
+				vmi.Spec.Domain.Devices.Interfaces[secondaryInterfaceIdx].PciAddress = fmt.Sprintf(pciAddressTemplate, secondaryInterfaceIdx)
+			}
+
+			vmi, err := createVMIAndWait(vmi)
+			Expect(err).ToNot(HaveOccurred())
+
+			for _, iface := range vmi.Spec.Domain.Devices.Interfaces {
+				if iface.SRIOV == nil {
+					continue
+				}
+				guestInterfaceName, err := findIfaceByMAC(virtClient, vmi, iface.MacAddress, 30*time.Second)
+				Expect(err).ToNot(HaveOccurred())
+				Expect(pciAddressExistsInGuestInterface(vmi, iface.PciAddress, guestInterfaceName)).To(Succeed())
+			}
+		})
+	})
+
 	Context("VMI connected to link-enabled SRIOV network", func() {
 		var sriovNode string
 
@@ -551,6 +585,11 @@ func pciAddressExistsInGuest(vmi *v1.VirtualMachineInstance, pciAddress string)
 	return console.RunCommand(vmi, command, 15*time.Second)
 }
 
+func pciAddressExistsInGuestInterface(vmi *v1.VirtualMachineInstance, pciAddress, interfaceName string) error {
+	command := fmt.Sprintf("grep -q PCI_SLOT_NAME=%s /sys/class/net/%s/device/uevent\n", pciAddress, interfaceName)
+	return console.RunCommand(vmi, command, 15*time.Second)
+}
+
 func getInterfaceNameByMAC(vmi *v1.VirtualMachineInstance, mac string) (string, error) {
 	for _, iface := range vmi.Status.Interfaces {
 		if iface.MAC == mac {
diff --git a/tests/windows_test.go b/tests/windows_test.go
index b82de14d2c3..65e28f36f28 100644
--- a/tests/windows_test.go
+++ b/tests/windows_test.go
@@ -26,6 +26,14 @@ import (
 	"time"
 
 	"kubevirt.io/kubevirt/tests/framework/checks"
+	"kubevirt.io/kubevirt/tests/libstorage"
+
+	"k8s.io/utils/pointer"
+
+	"kubevirt.io/kubevirt/pkg/controller"
+	"kubevirt.io/kubevirt/tests/libnode"
+
+	"kubevirt.io/kubevirt/pkg/virt-controller/watch/topology"
 
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
@@ -41,7 +49,6 @@ import (
 	"kubevirt.io/kubevirt/tests"
 	"kubevirt.io/kubevirt/tests/flags"
 	"kubevirt.io/kubevirt/tests/libnet"
-	"kubevirt.io/kubevirt/tests/libstorage"
 	"kubevirt.io/kubevirt/tests/libvmi"
 	"kubevirt.io/kubevirt/tests/util"
 )
@@ -75,20 +82,100 @@ var _ = Describe("[Serial][sig-compute]Windows VirtualMachineInstance", func() {
 		windowsVMI.Spec.Domain.Devices.Interfaces[0].Model = "e1000"
 	})
 
-	It("should be able to migrate when HyperV reenlightenment is enabled", func() {
-		var err error
+	Context("VMI with HyperV reenlightenment enabled", func() {
+		BeforeEach(func() {
+			windowsVMI.Spec.Domain.Features.Hyperv.Reenlightenment = &v1.FeatureState{Enabled: pointer.Bool(true)}
+		})
 
-		By("Creating a windows VM")
-		windowsVMI, err = virtClient.VirtualMachineInstance(util.NamespaceTestDefault).Create(windowsVMI)
-		Expect(err).ToNot(HaveOccurred())
-		tests.WaitForSuccessfulVMIStartWithTimeout(windowsVMI, 360)
+		When("TSC frequency is exposed on the cluster", func() {
+			It("should be able to migrate", func() {
+				if !isTSCFrequencyExposed(virtClient) {
+					Skip("TSC frequency is not exposed on the cluster")
+				}
+
+				var err error
+				By("Creating a windows VM")
+				windowsVMI, err = virtClient.VirtualMachineInstance(util.NamespaceTestDefault).Create(windowsVMI)
+				Expect(err).ToNot(HaveOccurred())
+				tests.WaitForSuccessfulVMIStartWithTimeout(windowsVMI, 360)
+
+				By("Migrating the VM")
+				migration := tests.NewRandomMigration(windowsVMI.Name, windowsVMI.Namespace)
+				migrationUID := tests.RunMigrationAndExpectCompletion(virtClient, migration, tests.MigrationWaitTime)
+
+				By("Checking VMI, confirm migration state")
+				tests.ConfirmVMIPostMigration(virtClient, windowsVMI, migrationUID)
+			})
+		})
+
+		When("TSC frequency is not exposed on the cluster", func() {
+
+			BeforeEach(func() {
+				if isTSCFrequencyExposed(virtClient) {
+					nodeList, err := virtClient.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
+					Expect(err).ToNot(HaveOccurred())
+
+					for _, node := range nodeList.Items {
+						stopNodeLabeller(node.Name, virtClient)
+						removeTSCFrequencyFromNode(node)
+					}
+				}
+			})
+
+			AfterEach(func() {
+				nodeList, err := virtClient.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
+				Expect(err).ToNot(HaveOccurred())
+
+				for _, node := range nodeList.Items {
+					_, isNodeLabellerStopped := node.Annotations[v1.LabellerSkipNodeAnnotation]
+					Expect(isNodeLabellerStopped).To(BeTrue())
+
+					updatedNode := resumeNodeLabeller(node.Name, virtClient)
+					_, isNodeLabellerStopped = updatedNode.Annotations[v1.LabellerSkipNodeAnnotation]
+					Expect(isNodeLabellerStopped).To(BeFalse(), "after node labeller is resumed, %s annotation is expected to disappear from node", v1.LabellerSkipNodeAnnotation)
+				}
+			})
+
+			It("should be able to start successfully", func() {
+				var err error
+				By("Creating a windows VM")
+				windowsVMI, err = virtClient.VirtualMachineInstance(util.NamespaceTestDefault).Create(windowsVMI)
+				Expect(err).ToNot(HaveOccurred())
+				tests.WaitForSuccessfulVMIStartWithTimeout(windowsVMI, 360)
+				winrnLoginCommand(virtClient, windowsVMI)
+			})
+
+			It("should be marked as non-migratable", func() {
+				var err error
+				By("Creating a windows VM")
+				windowsVMI, err = virtClient.VirtualMachineInstance(util.NamespaceTestDefault).Create(windowsVMI)
+				Expect(err).ToNot(HaveOccurred())
+				tests.WaitForSuccessfulVMIStartWithTimeout(windowsVMI, 360)
 
-		By("Migrating the VM")
-		migration := tests.NewRandomMigration(windowsVMI.Name, windowsVMI.Namespace)
-		migrationUID := tests.RunMigrationAndExpectCompletion(virtClient, migration, tests.MigrationWaitTime)
+				conditionManager := controller.NewVirtualMachineInstanceConditionManager()
+				isNonMigratable := func() error {
+					windowsVMI, err = virtClient.VirtualMachineInstance(util.NamespaceTestDefault).Get(windowsVMI.Name, &metav1.GetOptions{})
+					Expect(err).ToNot(HaveOccurred())
 
-		By("Checking VMI, confirm migration state")
-		tests.ConfirmVMIPostMigration(virtClient, windowsVMI, migrationUID)
+					cond := conditionManager.GetCondition(windowsVMI, v1.VirtualMachineInstanceIsMigratable)
+					const errFmt = "condition " + string(v1.VirtualMachineInstanceIsMigratable) + " is expected to be %s %s"
+
+					if statusFalse := k8sv1.ConditionFalse; cond.Status != statusFalse {
+						return fmt.Errorf(errFmt, "of status", string(statusFalse))
+					}
+					if notMigratableNoTscReason := v1.VirtualMachineInstanceReasonNoTSCFrequencyMigratable; cond.Reason != notMigratableNoTscReason {
+						return fmt.Errorf(errFmt, "of reason", notMigratableNoTscReason)
+					}
+					if !strings.Contains(cond.Message, "HyperV Reenlightenment") {
+						return fmt.Errorf(errFmt, "with message that contains", "HyperV Reenlightenment")
+					}
+					return nil
+				}
+
+				Eventually(isNonMigratable, 30*time.Second, time.Second).ShouldNot(HaveOccurred())
+				Consistently(isNonMigratable, 15*time.Second, 3*time.Second).ShouldNot(HaveOccurred())
+			})
+		})
 	})
 
 	Context("with winrm connection", func() {
@@ -380,3 +467,26 @@ func runCommandAndExpectOutput(virtClient kubecli.KubevirtClient, winrmcliPod *k
 		return output
 	}, time.Minute*1, time.Second*10).Should(MatchRegexp(expectedOutputRegex))
 }
+
+func isTSCFrequencyExposed(virtClient kubecli.KubevirtClient) bool {
+	nodeList, err := virtClient.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
+	Expect(err).ToNot(HaveOccurred())
+
+	for _, node := range nodeList.Items {
+		if _, isExposed := node.Labels[topology.TSCFrequencyLabel]; isExposed {
+			return true
+		}
+	}
+
+	return false
+}
+
+func removeTSCFrequencyFromNode(node k8sv1.Node) {
+	for _, baseLabelToRemove := range []string{topology.TSCFrequencyLabel, topology.TSCFrequencySchedulingLabel} {
+		for key, _ := range node.Labels {
+			if strings.HasPrefix(key, baseLabelToRemove) {
+				libnode.RemoveLabelFromNode(node.Name, key)
+			}
+		}
+	}
+}
