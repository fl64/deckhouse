diff --git a/pkg/network/infraconfigurators/macvtap.go b/pkg/network/infraconfigurators/macvtap.go
index 4b81ea2ff..4c02b4ac0 100644
--- a/pkg/network/infraconfigurators/macvtap.go
+++ b/pkg/network/infraconfigurators/macvtap.go
@@ -7,6 +7,7 @@ import (
 	"strconv"
 
 	"github.com/vishvananda/netlink"
+	"golang.org/x/sys/unix"
 
 	v1 "kubevirt.io/api/core/v1"
 	"kubevirt.io/client-go/log"
@@ -83,6 +84,15 @@ func (b *MacvtapPodNetworkConfigurator) GenerateNonRecoverableDHCPConfig() *cach
 		return &cache.DHCPConfig{IPAMDisabled: true}
 	}
 
+	b.podIfaceRoutes = []netlink.Route{{
+		LinkIndex: b.podNicLink.Attrs().Index,
+		Dst: &net.IPNet{
+			IP:   net.IPv4(0, 0, 0, 0),
+			Mask: net.CIDRMask(0, 32),
+		},
+		Scope: unix.RT_SCOPE_LINK,
+	}}
+
 	dhcpConfig := &cache.DHCPConfig{
 		MAC:          *b.vmMac,
 		IPAMDisabled: !b.ipamEnabled,
@@ -186,25 +196,25 @@ func (b *MacvtapPodNetworkConfigurator) GenerateNonRecoverableDomainIfaceSpec()
 }
 
 func (b *MacvtapPodNetworkConfigurator) learnInterfaceRoutes() error {
-	routes, err := b.handler.RouteList(b.podNicLink, netlink.FAMILY_V4)
-	if err != nil {
-		log.Log.Reason(err).Errorf("failed to get routes for %s", b.podNicLink.Attrs().Name)
-		return err
-	}
-	if len(routes) == 0 {
-		return fmt.Errorf("no gateway address found in routes for %s", b.podNicLink.Attrs().Name)
-	}
-	b.podIfaceRoutes = routes
+	b.podIfaceRoutes = []netlink.Route{{
+		LinkIndex: b.podNicLink.Attrs().Index,
+		Gw:        net.ParseIP("0.0.0.0"),
+		Dst: &net.IPNet{
+			IP:   net.IPv4(0, 0, 0, 0),
+			Mask: net.CIDRMask(0, 32),
+		},
+		Scope: unix.RT_SCOPE_LINK,
+	}}
 	return nil
 }
 
 func (b *MacvtapPodNetworkConfigurator) decorateDhcpConfigRoutes(dhcpConfig *cache.DHCPConfig) {
 	log.Log.V(4).Infof("the default route is: %s", b.podIfaceRoutes[0].String())
 	dhcpConfig.Gateway = b.podIfaceRoutes[0].Gw
-	if len(b.podIfaceRoutes) > 1 {
-		dhcpRoutes := virtnetlink.FilterPodNetworkRoutes(b.podIfaceRoutes, dhcpConfig)
-		dhcpConfig.Routes = &dhcpRoutes
-	}
+	//if len(b.podIfaceRoutes) > 1 {
+	//	dhcpRoutes := virtnetlink.FilterPodNetworkRoutes(b.podIfaceRoutes, dhcpConfig)
+	//	dhcpConfig.Routes = &dhcpRoutes
+	//}
 }
 
 func (b *MacvtapPodNetworkConfigurator) createMacvlan() error {
diff --git a/pkg/virt-config/feature-gates.go b/pkg/virt-config/feature-gates.go
index c905dbf0f..b9ecb1a61 100644
--- a/pkg/virt-config/feature-gates.go
+++ b/pkg/virt-config/feature-gates.go
@@ -30,7 +30,9 @@ const (
 	IgnitionGate      = "ExperimentalIgnitionSupport"
 	LiveMigrationGate = "LiveMigration"
 	// SRIOVLiveMigrationGate enables Live Migration for VM's with network SR-IOV interfaces.
-	SRIOVLiveMigrationGate     = "SRIOVLiveMigration"
+	SRIOVLiveMigrationGate = "SRIOVLiveMigration"
+	// ImmutableVMNetworking forces VM to immutable network configuration, and enable's Live Migration for VM's with bridged pod network
+	ImmutableVMNetworkingGate  = "ImmutableVMNetworking"
 	CPUNodeDiscoveryGate       = "CPUNodeDiscovery"
 	HypervStrictCheckGate      = "HypervStrictCheck"
 	SidecarGate                = "Sidecar"
@@ -108,6 +110,10 @@ func (config *ClusterConfig) SRIOVLiveMigrationEnabled() bool {
 	return config.isFeatureGateEnabled(SRIOVLiveMigrationGate)
 }
 
+func (config *ClusterConfig) ImmutableVMNetworkingEnabled() bool {
+	return config.isFeatureGateEnabled(ImmutableVMNetworkingGate)
+}
+
 func (config *ClusterConfig) HypervStrictCheckEnabled() bool {
 	return config.isFeatureGateEnabled(HypervStrictCheckGate)
 }
diff --git a/pkg/virt-handler/vm.go b/pkg/virt-handler/vm.go
index 4867c91a4..fed5913f0 100644
--- a/pkg/virt-handler/vm.go
+++ b/pkg/virt-handler/vm.go
@@ -2239,8 +2239,9 @@ func (d *VirtualMachineController) checkNetworkInterfacesForMigration(vmi *v1.Vi
 		return nil
 	}
 
-	if !netvmispec.IsPodNetworkWithMasqueradeBindingInterface(vmi.Spec.Networks, ifaces) {
-		return fmt.Errorf("cannot migrate VMI which does not use masquerade to connect to the pod network")
+	immutableVMNetworkingEnabled := d.clusterConfig.ImmutableVMNetworkingEnabled()
+	if !netvmispec.IsPodNetworkWithMasqueradeBindingInterface(vmi.Spec.Networks, ifaces) && !immutableVMNetworkingEnabled {
+		return fmt.Errorf("ImmutableVMNetworkingGate feature-gate is closed, cannot migrate VMI which does not use masquerade to connect to the pod network")
 	}
 
 	return nil
diff --git a/pkg/virt-handler/vm_test.go b/pkg/virt-handler/vm_test.go
index e6ab6f7b1..0ebf9105e 100644
--- a/pkg/virt-handler/vm_test.go
+++ b/pkg/virt-handler/vm_test.go
@@ -2414,7 +2414,7 @@ var _ = Describe("VirtualMachineInstance", func() {
 			Expect(condition.Reason).To(Equal(v1.VirtualMachineInstanceReasonVirtIOFSNotMigratable))
 		})
 
-		It("should not be allowed to live-migrate if the VMI does not use masquerade to connect to the pod network", func() {
+		It("should not be allowed to live-migrate if the VMI does not use masquerade to connect to the pod network when feature-gate ImmutableVMNetworkingEnabled is off", func() {
 			vmi := api2.NewMinimalVMI("testvmi")
 
 			strategy := v1.EvictionStrategyLiveMigrate
@@ -2493,7 +2493,7 @@ var _ = Describe("VirtualMachineInstance", func() {
 		})
 
 		Context("with network configuration", func() {
-			It("should block migration for bridge binding assigned to the pod network", func() {
+			It("should block migration for bridge binding assigned to the pod network when feature-gate ImmutableVMNetworking is off", func() {
 				vmi := api2.NewMinimalVMI("testvmi")
 				interface_name := "interface_name"
 
@@ -2515,7 +2515,36 @@ var _ = Describe("VirtualMachineInstance", func() {
 				err := controller.checkNetworkInterfacesForMigration(vmi)
 				Expect(err).To(HaveOccurred())
 			})
+			It("should not block migration for bridge binding assigned to the pod network when feature-gate ImmutableVMNetworking is on", func() {
+				vmi := api2.NewMinimalVMI("testvmi")
+				interface_name := "interface_name"
 
+				vmi.Spec.Networks = []v1.Network{
+					{
+						Name:          interface_name,
+						NetworkSource: v1.NetworkSource{Pod: &v1.PodNetwork{}},
+					},
+				}
+				vmi.Spec.Domain.Devices.Interfaces = []v1.Interface{
+					{
+						Name: interface_name,
+						InterfaceBindingMethod: v1.InterfaceBindingMethod{
+							Bridge: &v1.InterfaceBridge{},
+						},
+					},
+				}
+				config, _, _ := testutils.NewFakeClusterConfigUsingKVConfig(&v1.KubeVirtConfiguration{
+					DeveloperConfiguration: &v1.DeveloperConfiguration{
+						FeatureGates: []string{virtconfig.ImmutableVMNetworkingGate},
+					},
+				})
+				controller.clusterConfig = config
+
+				Expect(controller.checkNetworkInterfacesForMigration(vmi)).Should(Succeed())
+
+				err := controller.checkNetworkInterfacesForMigration(vmi)
+				Expect(err).ToNot(HaveOccurred())
+			})
 			It("should not block migration for masquerade binding assigned to the pod network", func() {
 				vmi := api2.NewMinimalVMI("testvmi")
 				interface_name := "interface_name"
